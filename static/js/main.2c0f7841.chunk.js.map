{"version":3,"sources":["web/comps/menu.tsx","web/utils/errors.ts","web/utils/leveldb.ts","web/utils/db.ts","web/utils/abstract_page.ts","common/models.ts","web/utils/abstract_page_react.ts","web/comps/topic_page.tsx","web/comps/big_textarea.tsx","web/comps/note_page.tsx","web/comps/login_page.tsx","web/comps/scroll.tsx","web/serviceWorker.ts","index.tsx","web/comps/app.tsx"],"names":["Menu","props","className","children","style","clear","reportError","err","opts","Promise","resolve","then","catch","e","console","error","DataFactory","N3","nested","db","name","sublevel","valueEncoding","dbList","dbNamespace","base","basedb","RdfStore","leveljs","dataFactory","levelup","remoteDbMemoized","namedNode","getTopic","topicKey","get","s","md5","getNotes","topicId","a","notesLevelDB","getAll","list","map","n","text","addNote","startsWith","getLastSeq","lastSeq","id","cuid","payload","_id","topic_id","seq","created_at","Date","now","trim","put","attemptNoteUpload","file","fn","configure","value","JSON","parse","localStorage","couchdb_target","sync","isConfigured","navigator","onLine","getDbTarget","remoteDb","getRemoteDb","info","at","uploadNotes","sourceDb","asyncLib","doc","undefined","docId","Error","status","reason","topicNotes","del","existing","log","initialize","syncToLevelDB","importTopicsToLevelDB","updateLevelDB","allDocs","include_docs","startkey","endkey","update_seq","rows","resultSequence","ops","flatMap","type","key","lastSlashItem","stripDoc","push","batch","changes","since","limit","batch_size","resultLastSeq","last_seq","results","length","change","deleted","config","PouchDB","url","auth","configsLevelDB","note","v","split","reverse","options","reject","createValueStream","on","data","_rev","NestedSectionListFieldNames","LastSectionListFieldNames","TodoListFieldNames","buildAbstractPage","title","sections","all","todoSection","frontSection","listSections","otherFieldsSection","deriveTitle","breadcrumbs","flat","listFieldNameDivs","divs","isShallow","listIsShallow","maybeLabelRefs","sectionDoc","topicSection","names","field","heading","p","appendQueueToPage","notes","forEach","item","queue","unshift","refToTextObject","topic","ref","label","maybeResolveSrc","src","srcNode","l","join","link","search","models","every","context","fragments","slice","contextPaths","fragment","index","useAbstractPage","useState","pageHolder","setState","loaded","page","TopicHeader","Breadcrumbs","TopicPage","match","params","to","i","simpleList","d","buildAnchorElement","refLink","stringify","textItem","obj","mobile","document","documentElement","clientWidth","target","replace","indexOf","filter","rel","href","encodeURIComponent","cssClass","encodeURI","BigTextAreaPage","handler","restProps","textValue","setTextValue","onSubmitHandler","preventDefault","onClick","onKeyDown","which","metaKey","shiftKey","autoComplete","autoCapitalize","required","onChange","NotePage","history","LoginPage","LoginRedirector","withRouter","dbInitialized","location","pathname","ScrollToTopInner","prevProps","this","window","scrollTo","React","Component","ScrollToTop","Boolean","hostname","ReactDOM","render","basename","process","from","exact","path","component","getElementById","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.2c0f7841.chunk.js","sourcesContent":["import React, { ReactNode } from 'react';\nimport './menu.css';\n\ninterface MenuProps {\n  children: ReactNode;\n}\n\nexport const Menu: React.FC<MenuProps> = props => {\n  return (\n    <div>\n      <ul className=\"menu\">{props.children}</ul>\n      <div style={{ clear: 'both' }}></div>\n    </div>\n  );\n};\n","export function reportError(err: any, opts?: any) {\n  if (typeof err === 'function') {\n    Promise.resolve()\n      .then(err)\n      .catch(e => reportError(e, opts));\n  } else {\n    if (!opts) {\n      opts = {};\n    }\n    opts.err = err;\n    console.error(opts);\n    console.error(err);\n  }\n}\n","import levelup, { LevelUp } from 'levelup';\nimport leveljs from 'level-js';\nimport sublevel from 'subleveldown';\nimport { AbstractLevelDOWN, AbstractIterator } from 'abstract-leveldown';\nimport { RdfStore } from 'quadstore';\nimport * as N3 from 'n3';\n\nconst { DataFactory } = N3;\n\nexport type TypedLevelUp<V> = LevelUp<\n  AbstractLevelDOWN<string, V>,\n  AbstractIterator<string, V>\n>;\n\nexport function nested<V = any>(\n  db: TypedLevelUp<any>,\n  name: string\n): TypedLevelUp<V> {\n  return sublevel(db, name, { valueEncoding: 'id' });\n}\n\nconst dbList = {} as { [key: string]: TypedLevelUp<any> };\nexport function dbNamespace<V>(name: string): TypedLevelUp<V> {\n  if (!dbList[name]) {\n    dbList[name] = sublevel(base(), name, { valueEncoding: 'id' });\n  }\n\n  return dbList[name] as TypedLevelUp<V>;\n}\n\nexport const rdfStore = new RdfStore(leveljs('rdf'), {\n  dataFactory: DataFactory,\n});\n\nlet basedb: TypedLevelUp<any>;\nexport function base(): TypedLevelUp<any> {\n  if (!basedb) {\n    basedb = levelup(leveljs('wiki'));\n  }\n\n  return basedb;\n}\n","import PouchDB from 'pouchdb';\nimport md5 from 'blueimp-md5';\nimport cuid from 'cuid';\nimport { AbstractIteratorOptions, AbstractBatch } from 'abstract-leveldown';\nimport * as asyncLib from 'async';\n\nimport { reportError } from './errors';\nimport { dbNamespace, nested, base, rdfStore, TypedLevelUp } from './leveldb';\nimport * as N3 from 'n3';\nimport * as models from '../../common/models';\n\nconst { DataFactory } = N3;\nconst { namedNode } = DataFactory;\n\nexport function getTopic(topicKey: string): Promise<models.Doc> {\n  return dbNamespace<models.Doc>('topics').get(hash(topicKey));\n}\n\nexport async function pokeBear(topicId: string) {\n  const shortId = topicId.slice(1);\n\n  const tuples = await rdfStore.get({\n    subject: namedNode('https://curzonj.github.io/brain/#' + shortId),\n  });\n  console.log(tuples);\n}\nexport async function getNotes(topicId: string): Promise<string[]> {\n  const notesLevelDB = nested<models.NewNote>(dbNamespace('notes'), topicId);\n  const list = await getAll(notesLevelDB);\n\n  // merely by returning the entire list here, unsaved notes\n  // would gain the more link, but if you were to add a note\n  // onto that unsaved note, the sync would break\n  return list.map(n => n.text);\n}\n\nexport async function addNote(topicId: string, text: string) {\n  if (!topicId.startsWith('/')) {\n    topicId = `/${topicId}`;\n  }\n  if (topicId === '/index') {\n    topicId = '/inbox';\n  }\n\n  const lastSeq = await getLastSeq();\n  const notesLevelDB = nested<models.NewNote>(dbNamespace('notes'), topicId);\n  const id = cuid();\n  const payload = {\n    _id: `$/queue/${topicId}/${id}`,\n    topic_id: topicId,\n    seq: lastSeq,\n    created_at: Date.now(),\n    id: `/${id}`,\n    text: text.trim(),\n  } as models.NewNote;\n\n  await notesLevelDB.put(id, payload);\n\n  reportError(async () => attemptNoteUpload(payload), {\n    file: 'db',\n    fn: 'attemptNoteUpload',\n  });\n}\nexport async function configure(value: string) {\n  JSON.parse(value);\n  localStorage.couchdb_target = value;\n\n  await sync();\n}\n\nasync function isConfigured(): Promise<boolean> {\n  if (!navigator.onLine) {\n    return true;\n  }\n\n  const config = getDbTarget();\n  if (!config) {\n    return false;\n  }\n\n  const remoteDb = getRemoteDb();\n\n  // TODO once I have a better idea of what errors from\n  // this can look like I'll delete the config and return\n  // false sometimes\n  reportError(async () => remoteDb.info(), {\n    at: 'db.isConfigured',\n  });\n\n  return true;\n}\n\nexport async function uploadNotes(sourceDb: PouchDB.Database) {\n  const notesLevelDB = dbNamespace<models.NewNote>('notes');\n  const list = await getAll(notesLevelDB);\n\n  await asyncLib.mapSeries(list, async doc => {\n    const docId = doc._id;\n\n    if (docId === undefined) {\n      return reportError(new Error('doc is missing _id'), {\n        file: 'db',\n        fn: 'uploadNotes',\n        doc,\n      });\n    }\n\n    const existing = await sourceDb\n      .get(docId)\n      .catch(async (e: PouchDB.Core.Error) => {\n        if (e.status !== 404) {\n          reportError(e, {\n            file: 'db',\n            fn: 'uploadNotes',\n            doc,\n          });\n\n          return e;\n        }\n\n        if (e.reason === 'deleted') {\n          // the translation between these IDs and couchdb is a\n          // little broken so it's easier to just delete them from levelDB\n          // when they are deleted from couchdb\n          const topicNotes = nested(dbNamespace('notes'), doc.topic_id);\n          await topicNotes.del(doc.id);\n\n          return e;\n        }\n\n        return;\n      });\n\n    if (existing) {\n      console.log({\n        file: 'db',\n        fn: 'uploadNotes',\n        at: 'skip',\n        doc,\n        existing,\n      });\n    } else {\n      await sourceDb.put(doc).catch(e =>\n        reportError(e, {\n          file: 'db',\n          fn: 'uploadNotes',\n          doc,\n        })\n      );\n    }\n  });\n}\n\nexport async function initialize(): Promise<boolean> {\n  const ready = await isConfigured();\n  if (!ready) {\n    return false;\n  }\n\n  // Don't wait for this\n  reportError(sync);\n\n  return true;\n}\n\nasync function sync() {\n  if (!navigator.onLine) {\n    return;\n  }\n\n  const remoteDb = getRemoteDb();\n\n  await syncToLevelDB(remoteDb);\n  await uploadNotes(remoteDb);\n}\n\nasync function syncToLevelDB(sourceDb: PouchDB.Database) {\n  const lastSeq = await getLastSeq();\n  if (!lastSeq) {\n    await importTopicsToLevelDB(sourceDb);\n  } else {\n    await updateLevelDB(sourceDb, lastSeq);\n  }\n}\n\nasync function importTopicsToLevelDB(sourceDb: PouchDB.Database) {\n  const { rows, update_seq: resultSequence } = await sourceDb.allDocs<\n    models.Doc\n  >({\n    include_docs: true,\n    startkey: `$/topics/`,\n    endkey: `$/topics/\\uFFF0`,\n    update_seq: true,\n  });\n  const ops = rows.flatMap(({ doc }) => {\n    if (!doc) {\n      return [];\n    }\n\n    return {\n      type: 'put',\n      key: `!topics!${lastSlashItem(doc._id)}`,\n      value: stripDoc(doc),\n    } as AbstractBatch;\n  });\n\n  ops.push({ type: 'put', key: '!configs!lastSeq', value: resultSequence });\n\n  await base().batch(ops);\n}\n\nasync function updateLevelDB(\n  sourceDb: PouchDB.Database,\n  lastSeq: string | number\n): Promise<void> {\n  const { last_seq: resultLastSeq, results } = await sourceDb.changes<\n    models.CouchDocTypes\n  >({\n    include_docs: true,\n    since: lastSeq,\n    limit: 100,\n    batch_size: 100,\n  });\n\n  if (results.length === 0) {\n    return;\n  }\n\n  const ops: AbstractBatch[] = results.flatMap(change => {\n    if (change.id.startsWith('$/queue/')) {\n      // TODO currently this means that notes from other devices\n      // won't show up until they get synced on my laptop\n      return [];\n    } else if (change.deleted) {\n      return {\n        type: 'del',\n        key: `!topics!${lastSlashItem(change.id)}`,\n      };\n    } else if (change.doc) {\n      return {\n        type: 'put',\n        key: `!topics!${lastSlashItem(change.id)}`,\n        value: stripDoc(change.doc),\n      };\n    } else {\n      return [];\n    }\n  });\n\n  ops.push({ type: 'put', key: '!configs!lastSeq', value: resultLastSeq });\n\n  await base().batch(ops);\n\n  return updateLevelDB(sourceDb, resultLastSeq);\n}\n\nlet remoteDbMemoized: PouchDB.Database;\nfunction getRemoteDb() {\n  if (!remoteDbMemoized) {\n    const config = getDbTarget();\n    remoteDbMemoized = new PouchDB(config.url, config);\n  }\n\n  return remoteDbMemoized;\n}\n\nfunction getDbTarget() {\n  if (localStorage.couchdb_target) {\n    try {\n      const config = JSON.parse(localStorage.couchdb_target);\n      if (!config.url || !config.auth) {\n        throw new Error('Invalid db target config');\n      }\n\n      return config;\n    } catch (e) {\n      reportError(e);\n      delete localStorage.couchdb_target;\n    }\n  }\n\n  return null;\n}\n\nasync function getLastSeq(): Promise<number | string | undefined> {\n  const configsLevelDB = dbNamespace<number | string>('configs');\n  return configsLevelDB.get('lastSeq').catch((err: Error) => undefined);\n}\n\nasync function attemptNoteUpload(note: models.Note) {\n  if (!navigator.onLine) {\n    return;\n  }\n\n  const remoteDb = getRemoteDb();\n  await remoteDb.put(note);\n}\n\nexport function hash(s: string) {\n  return md5(s);\n}\n\nfunction lastSlashItem(docId: string) {\n  return reverseSlashes(docId)[0];\n}\n\nfunction reverseSlashes(v: string) {\n  return v.split('/').reverse();\n}\n\nfunction getAll<D>(\n  db: TypedLevelUp<D>,\n  options?: AbstractIteratorOptions\n): Promise<D[]> {\n  const list = [] as D[];\n  return new Promise((resolve, reject) => {\n    db.createValueStream(options)\n      .on('data', (data: D) => list.push(data))\n      .on('error', (err: Error) => reject(err))\n      .on('end', () => resolve(list));\n  });\n}\n\nfunction stripDoc<D extends {}>(doc: PouchDB.Core.ExistingDocument<D>): D {\n  delete doc._id;\n  delete doc._rev;\n\n  return doc;\n}\n","import * as db from './db';\nimport * as models from '../../common/models';\nimport { reportError } from './errors';\n\nconst NestedSectionListFieldNames = [\n  ['next', 'Next'],\n  ['later', 'Later'],\n  ['related', 'Related'],\n  ['mentions', 'Mentions'],\n  ['links', 'Links'],\n];\n\nconst LastSectionListFieldNames = [\n  ['related', 'Related'],\n  ['mentions', 'Mentions'],\n  ['links', 'Links'],\n  ['queue', 'Queue'],\n];\n\nconst TodoListFieldNames = [['next', 'Next'], ['later', 'Later']];\n\nexport interface AbstractPage {\n  title: string;\n  breadcrumbs?: any[];\n  sections: Section[];\n}\n\nexport interface Section {\n  title?: string;\n  text?: any;\n  list?: any[];\n  divs?: any[];\n}\n\nexport async function buildAbstractPage(\n  topicId: string\n): Promise<AbstractPage> {\n  if (!topicId.startsWith('/')) {\n    topicId = `/${topicId}`;\n  }\n\n  const doc = await db.getTopic(topicId).catch(reportError);\n  if (!doc) {\n    return {\n      title: topicId,\n      sections: [\n        {\n          text: 'This page does not have any content yet.',\n        },\n      ],\n    };\n  }\n\n  const sections = await Promise.all([\n    todoSection(doc),\n    frontSection(doc),\n    listSections(doc),\n    otherFieldsSection(doc),\n  ]);\n\n  return {\n    title: deriveTitle(doc),\n    breadcrumbs: await breadcrumbs(doc),\n    sections: sections.flat(),\n  };\n}\n\nasync function todoSection(doc: models.Doc): Promise<Section | never[]> {\n  const divs = await listFieldNameDivs(TodoListFieldNames, doc);\n  if (divs.length === 0) {\n    return [];\n  }\n\n  return {\n    title: 'TODO',\n    divs,\n  };\n}\n\nasync function frontSection(doc: models.Doc) {\n  const { list } = doc;\n  const isShallow = listIsShallow(list);\n\n  if (!doc.text && !isShallow) {\n    return [];\n  }\n\n  return {\n    // TODO src, props\n    text: doc.text,\n    list: await maybeLabelRefs(isShallow ? undefined : doc.list),\n  } as Section;\n}\n\nasync function listSections(doc: models.Doc): Promise<Section[]> {\n  const { list } = doc;\n  if (!list || listIsShallow(list)) {\n    return [];\n  }\n\n  return Promise.all(\n    list.map(async (s: any) => {\n      if (typeof s === 'string' && s.startsWith('/')) {\n        const sectionDoc = await db.getTopic(s);\n        return topicSection(sectionDoc);\n      }\n\n      return {\n        text: s,\n      };\n    })\n  );\n}\n\nasync function topicSection(doc: models.Doc): Promise<Section> {\n  return {\n    title: deriveTitle(doc),\n    text: doc.text,\n    list: await maybeLabelRefs(doc.list),\n    divs: await listFieldNameDivs(NestedSectionListFieldNames, doc),\n  } as Section;\n}\n\nasync function listFieldNameDivs(names: string[][], doc: models.Doc) {\n  const p = await Promise.all(\n    names.map(async ([field, heading]) => {\n      if (!doc[field]) return [];\n      return [\n        {\n          heading,\n          list: await maybeLabelRefs(doc[field] as any[]),\n        },\n      ];\n    })\n  );\n\n  return p.flat();\n}\n\n// TODO this isn't working\nasync function appendQueueToPage(doc: models.Doc) {\n  const notes = await db.getNotes(doc.id);\n  if (notes.length === 0) {\n    return;\n  }\n\n  notes.forEach(item => {\n    doc.queue = doc.queue || [];\n    doc.queue.unshift(item);\n  });\n}\n\nasync function otherFieldsSection(doc: models.Doc) {\n  await appendQueueToPage(doc);\n\n  const divs = await listFieldNameDivs(LastSectionListFieldNames, doc);\n  if (divs.length === 0) {\n    return [];\n  }\n\n  return {\n    divs,\n  };\n}\n\nasync function maybeLabelRefs(\n  list: undefined | any[]\n): Promise<undefined | any[]> {\n  if (!list || list.length === 0) return;\n\n  return Promise.all(\n    list.map(async v => {\n      // v could be an object from links\n      if (typeof v === 'string' && v.startsWith('/')) {\n        return refToTextObject(v);\n      }\n\n      return v;\n    })\n  );\n}\n\nasync function refToTextObject(topicId: string) {\n  const topic = await db.getTopic(topicId);\n  if (topic.title) {\n    return {\n      ref: topicId,\n      label: deriveTitle(topic),\n    };\n  } else if (!topic.text) {\n    return {\n      ref: topicId,\n      label: deriveTitle(topic),\n    };\n  } else {\n    return {\n      ref: topicId,\n      text: topic.text,\n      src: await maybeResolveSrc(topic.src),\n    };\n  }\n}\n\n// could be lots of things\nasync function maybeResolveSrc(src: undefined | models.Link) {\n  if (!src) return;\n  if (typeof src !== 'string') {\n    return src;\n  } else if (src.startsWith('/')) {\n    const srcNode = await db.getTopic(src);\n    return {\n      ref: src,\n      label: deriveTitle(srcNode),\n    };\n  } else {\n    return src;\n  }\n}\n\nfunction deriveTitle(n: models.Doc): string {\n  if (!n) return 'Missing Page';\n\n  let title = n.title || n.join;\n\n  if (!title && n.link) {\n    if (typeof n.link === 'string') {\n      title = n.link;\n    } else if (models.isLabeledLink(n.link)) {\n      title = n.link.link;\n    } else if (models.isSearchLink(n.link)) {\n      title = n.link.search;\n    }\n  }\n\n  return title || 'Note';\n}\n\nfunction listIsShallow(list: undefined | any[]): boolean {\n  return (\n    list !== undefined &&\n    list.every(s => typeof s === 'string' && !s.startsWith('/'))\n  );\n}\n\nasync function breadcrumbs(doc: models.Doc) {\n  if (!doc.context) return undefined;\n\n  // This dates back to the deeply nested path style keys used\n  // as contexts\n  const fragments: string[] = doc.context.split('/').slice(1);\n  const contextPaths = fragments.map(\n    (fragment, index) => `/${fragments.slice(0, index + 1).join('/')}`\n  );\n\n  return maybeLabelRefs(contextPaths);\n}\n","import PouchDB from 'pouchdb';\nimport { StringQuad, ValidLiteralType } from './rdf';\n\nexport interface Note {\n  id: string;\n  text: string;\n  created_at: number;\n  seq: number | string;\n  topic_id: string;\n}\n\nexport interface ShortDoc {\n  created_at?: number;\n  title?: string;\n  join?: string;\n  text?: string;\n  src?: Link;\n  link?: Link;\n  context?: string;\n  topic_id?: string;\n  queue?: string[];\n  list?: string[];\n  links?: LinkList;\n  props?: DumbProps;\n  patches?: DocChangeEntry[];\n  [key: string]: DocValueTypes;\n}\n\nexport interface Doc extends ShortDoc {\n  id: string;\n  created_at?: number;\n  [key: string]: DocValueTypes;\n}\n\nexport interface DumbProps {\n  quanity?: string;\n  author?: string;\n  [key: string]: string | undefined;\n}\n\nexport interface DocChangeEntry {\n  op: 'add' | 'remove';\n  field: string;\n  value: ValidLiteralType;\n}\n\nexport type LinkList = Link[];\nexport type Link = string | LabeledLink | SearchLink;\nexport interface SearchLink {\n  search: string;\n}\nexport interface LabeledLink {\n  title: string;\n  link: string;\n}\nexport type EditorArrayItemTypes = Link | MaybeLabeledRef;\nexport type DocArrayValueTypes = string[] | LinkList;\nexport type RegularDocValueTypes =\n  | string[]\n  | string\n  | number\n  | undefined\n  | Link\n  | LinkList\n  | DumbProps;\nexport type DocValueTypes = RegularDocValueTypes | DocChangeEntry[];\n\nexport type ExistingDoc = PouchDB.Core.ExistingDocument<Doc>;\nexport type DocUpdate = PouchDB.Core.PutDocument<Doc> & PouchDB.Core.IdMeta;\nexport type RdfDoc = StringQuad;\nexport type CouchDocTypes = Doc | RdfDoc | Note;\nexport type NewNote = PouchDB.Core.PutDocument<Note>;\n\nexport interface EditorDoc {\n  text?: string;\n  queue?: RefList;\n  links?: LinkList;\n  [key: string]: EditorValueTypes;\n}\n\nexport interface LabeledRef {\n  label: string;\n  ref: string;\n}\n\nexport type EditorValueTypes = RegularDocValueTypes | RefList;\nexport type RefList = MaybeLabeledRef[];\nexport type MaybeLabeledRef = string | LabeledRef;\nexport type EditorStructure = Record<string, EditorDoc>;\n\nexport const StorageFields = ['_rev', '_id', '_deleted', 'id', 'patches'];\nexport function removeStorageAttributes(\n  doc: ExistingDoc | DocUpdate\n): ShortDoc {\n  const clone = { ...doc } as any;\n\n  StorageFields.forEach(k => {\n    delete clone[k];\n  });\n\n  return clone as ShortDoc;\n}\n\nexport function isStorageField(k: string) {\n  return StorageFields.indexOf(k) > -1;\n}\n\nexport function isPatches(k: string, v: DocValueTypes): v is DocChangeEntry[] {\n  return Array.isArray(v) && k === 'patches';\n}\n\nexport function isDocArrayField(\n  k: string,\n  v: DocValueTypes\n): v is DocArrayValueTypes {\n  return Array.isArray(v) && k !== 'patches';\n}\n\nexport function isLabeledRef(l: any): l is LabeledRef {\n  if (typeof l === 'string') {\n    return false;\n  }\n\n  return !!(l as LabeledRef).ref;\n}\n\nexport function isSearchLink(l: any): l is SearchLink {\n  if (typeof l === 'string') {\n    return false;\n  }\n\n  return !!(l as SearchLink).search;\n}\n\nexport function isLabeledLink(l: any): l is LabeledLink {\n  if (typeof l === 'string') {\n    return false;\n  }\n\n  return !!(l as LabeledLink).link;\n}\n\nexport function isProps(k: string, o: DocValueTypes): o is DumbProps {\n  return k === 'props';\n}\n","import { useState } from 'react';\nimport { buildAbstractPage, AbstractPage } from './abstract_page';\nimport { reportError } from '../utils/errors';\n\nexport interface LoadedAbstractPage {\n  loaded?: string;\n  page?: AbstractPage;\n}\n\nexport function useAbstractPage(topicId: string): AbstractPage | undefined {\n  const [pageHolder, setState] = useState({} as LoadedAbstractPage);\n\n  if (pageHolder.loaded !== topicId) {\n    reportError(async () => {\n      const page = await buildAbstractPage(topicId);\n      setState({\n        page,\n        loaded: topicId,\n      });\n    });\n  }\n\n  return pageHolder.page;\n}\n","import React from 'react';\nimport { RouteComponentProps } from 'react-router';\nimport { Link } from 'react-router-dom';\nimport { Menu } from './menu';\nimport './topic_page.css';\nimport { useAbstractPage } from '../utils/abstract_page_react';\nimport { AbstractPage, Section } from '../utils/abstract_page';\n\nexport function TopicHeader(props: { topicId: string; page?: AbstractPage }) {\n  const { page, topicId } = props;\n\n  return (\n    <div className=\"header\">\n      {page && <Breadcrumbs breadcrumbs={page.breadcrumbs} />}\n      <h1 className=\"title\">{page ? page.title : topicId}</h1>\n    </div>\n  );\n}\n\nexport function TopicPage(props: RouteComponentProps<{ topicId: string }>) {\n  const { topicId } = props.match.params;\n  const page = useAbstractPage(topicId);\n\n  return (\n    <div className=\"topicPage\">\n      <Menu>\n        <li>\n          <Link to=\"/index\">index</Link>\n        </li>\n        <li>\n          <Link to={`/add_note/${topicId}`}>add note</Link>\n        </li>\n      </Menu>\n\n      <TopicHeader topicId={topicId} page={page} />\n\n      {page ? (\n        renderSections(page.sections)\n      ) : (\n        <section>\n          <p>Loading...</p>\n        </section>\n      )}\n    </div>\n  );\n}\n\nfunction renderSections(sections: Section[]) {\n  return sections.map((s, i) => {\n    return (\n      <section key={i}>\n        {s.title && <h2 className=\"title\">{s.title}</h2>}\n        {s.text && <p>{s.text}</p>}\n        {s.list && simpleList(s.list)}\n        {s.divs && sectionDivs(s.divs)}\n      </section>\n    );\n  });\n}\n\nfunction sectionDivs(divs: any[]) {\n  return divs.map((d, i) => {\n    return (\n      <div key={i}>\n        {d.heading && <h3 className=\"title\">{d.heading}</h3>}\n        {simpleList(d.list)}\n      </div>\n    );\n  });\n}\n\nfunction simpleList(list: any[]) {\n  return (\n    <ul>\n      {list.map((s, i) => (\n        <li key={i}>{textItem(s)}</li>\n      ))}\n    </ul>\n  );\n}\n\nfunction Breadcrumbs(props: { breadcrumbs: undefined | any[] }) {\n  return <></>;\n}\n\nfunction textItem(item: any) {\n  if (typeof item === 'string') {\n    if (item.startsWith('http')) {\n      return buildAnchorElement(item);\n    }\n    return <p>{item}</p>;\n  } else if (item.link || item.search) {\n    return buildAnchorElement(item);\n  } else if (item.label) {\n    return refLink(item.ref, item.label);\n  } else {\n    return (\n      <p>\n        {item.text}\n        {renderSrc(item.src)}({refLink(item.ref, 'more', 'moreLink')})\n      </p>\n    );\n  }\n}\n\nfunction renderSrc(src: any) {\n  if (!src) {\n    return undefined;\n  } else if (typeof src === 'string') {\n    return <span>- ${src}</span>;\n  } else if (src.ref) {\n    return refLink(src.ref, src.label);\n  } else {\n    // TODO replace this, it could be a labeled link\n    return <pre>{JSON.stringify(src)}</pre>;\n  }\n}\n\nfunction buildAnchorElement(obj: any) {\n  const mobile = document.documentElement.clientWidth < 800;\n\n  if (typeof obj === 'string' || obj.link) {\n    let target = obj;\n    let text = obj;\n\n    if (typeof obj !== 'string') {\n      target = obj.link;\n      text = obj.title || obj.link;\n    }\n\n    if (text.startsWith('https://en.wikipedia.org/wiki')) {\n      text = `Wikipedia: ${text\n        .replace('https://en.wikipedia.org/wiki/', '')\n        .replace(/_/g, ' ')}`;\n    } else if (text.indexOf('pinboard.in/u:curzonj/') !== -1) {\n      text = `Pinboard: ${text\n        .replace(/https?:\\/\\/pinboard.in\\/u:curzonj\\//, '')\n        .split('/')\n        .filter((l: string) => l !== '')\n        .flatMap((l: string) => l.replace(/^t:/, ''))\n        .join(', ')}`;\n      target = target.replace(/^http:\\/\\//, 'https://');\n      if (mobile) {\n        target = target.replace('pinboard.in', 'm.pinboard.in');\n      }\n    }\n\n    return (\n      <a target=\"_blank\" rel=\"noopener noreferrer\" href={target}>\n        {text}\n      </a>\n    );\n  }\n  if (obj.search) {\n    return (\n      <a\n        target=\"_blank\"\n        rel=\"noopener noreferrer\"\n        href={'https://google.com/search?q=' + encodeURIComponent(obj.search)}\n      >\n        Google: {obj.search}\n      </a>\n    );\n  }\n\n  return undefined;\n}\n\nfunction refLink(link: string, text: string, cssClass: string = 'refLink') {\n  return (\n    <Link className={cssClass} to={encodeURI(link)}>\n      {text || link}\n    </Link>\n  );\n}\n","import React, { useState } from 'react';\nimport { reportError } from '../utils/errors';\nimport { Menu } from './menu';\n\ntype Props = {\n  handler: (s: string) => void;\n} & React.HTMLAttributes<HTMLDivElement>;\n\nexport const BigTextAreaPage: React.FC<Props> = ({\n  handler,\n  children,\n  ...restProps\n}) => {\n  const [textValue, setTextValue] = useState('');\n\n  function onKeyDown(e: React.KeyboardEvent<HTMLTextAreaElement>) {\n    if (e.which === 13 && (e.metaKey || e.shiftKey)) onSubmitHandler(e);\n  }\n\n  function onSubmitHandler(e: React.SyntheticEvent) {\n    e.preventDefault();\n    reportError(() => handler(textValue));\n  }\n\n  function onChange(e: React.ChangeEvent<HTMLTextAreaElement>) {\n    if (e && e.target) {\n      setTextValue(e.target.value);\n    }\n  }\n\n  return (\n    <div {...restProps}>\n      <Menu>\n        <li>\n          <button\n            type=\"button\"\n            className=\"link-button\"\n            onClick={onSubmitHandler}\n          >\n            done\n          </button>\n        </li>\n      </Menu>\n\n      {children}\n\n      <form>\n        <textarea\n          onKeyDown={onKeyDown}\n          autoComplete=\"on\"\n          autoCapitalize=\"sentences\"\n          required\n          onChange={onChange}\n          value={textValue}\n        ></textarea>\n      </form>\n    </div>\n  );\n};\n","import React from 'react';\nimport { RouteComponentProps } from 'react-router';\nimport { useAbstractPage } from '../utils/abstract_page_react';\nimport { addNote } from '../utils/db';\nimport { TopicHeader } from './topic_page';\nimport { BigTextAreaPage } from './big_textarea';\n\nexport const NotePage: React.FC<\n  RouteComponentProps<{ topicId: string }>\n> = props => {\n  const { topicId } = props.match.params;\n  const page = useAbstractPage(topicId);\n\n  async function onSubmit(text: string) {\n    if (text.trim() !== '') {\n      await addNote(topicId, text);\n    }\n\n    props.history.push(`/${topicId}`);\n  }\n\n  return (\n    <BigTextAreaPage className=\"topicPage\" handler={onSubmit}>\n      <TopicHeader topicId={topicId} page={page} />\n    </BigTextAreaPage>\n  );\n};\n","import React, { useState } from 'react';\nimport { withRouter, RouteComponentProps } from 'react-router';\nimport { reportError } from '../utils/errors';\nimport * as db from '../utils/db';\nimport { BigTextAreaPage } from './big_textarea';\n\nexport const LoginPage: React.FC<RouteComponentProps> = props => {\n  async function onSubmit(text: string) {\n    // This await actually waits for the full database\n    // to finish loading, so it won't try and render the index\n    // until the data is available\n    await db.configure(text);\n    props.history.push('/index');\n  }\n\n  return (\n    <BigTextAreaPage handler={onSubmit}>\n      <div className=\"header\">\n        <h1 className=\"title\">Enter the configuration</h1>\n      </div>\n    </BigTextAreaPage>\n  );\n};\n\nexport const LoginRedirector = withRouter((props: RouteComponentProps) => {\n  const [dbInitialized, setState] = useState(false);\n\n  if (!dbInitialized && props.location.pathname !== '/login') {\n    reportError(async () => {\n      const ok = await db.initialize();\n      if (ok) {\n        setState(true);\n      } else {\n        props.history.push('/login');\n      }\n    });\n  }\n\n  return <></>;\n});\n","import React from 'react';\nimport { withRouter, RouteComponentProps } from 'react-router';\n\nclass ScrollToTopInner extends React.Component<RouteComponentProps> {\n  componentDidUpdate(prevProps: RouteComponentProps) {\n    if (this.props.location.pathname !== prevProps.location.pathname) {\n      window.scrollTo(0, 0);\n    }\n  }\n\n  render() {\n    return this.props.children;\n  }\n}\nexport const ScrollToTop = withRouter(ScrollToTopInner);\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './web/index.css';\nimport { App } from './web/comps/app';\nimport * as serviceWorker from './web/serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","import React from 'react';\nimport {\n  BrowserRouter as Router,\n  Route,\n  Switch,\n  Redirect,\n} from 'react-router-dom';\nimport './app.css';\nimport { TopicPage } from './topic_page';\nimport { NotePage } from './note_page';\nimport { LoginPage, LoginRedirector } from './login_page';\nimport { ScrollToTop } from './scroll';\n\nexport const App: React.FC = () => {\n  return (\n    <Router basename={process.env.PUBLIC_URL}>\n      <LoginRedirector />\n\n      <ScrollToTop>\n        <Switch>\n          <Redirect from=\"/\" to=\"/index\" exact />\n          <Route path=\"/login\" component={LoginPage} />\n          <Route path=\"/add_note/:topicId\" component={NotePage} />\n          <Route path=\"/:topicId\" component={TopicPage} />\n        </Switch>\n      </ScrollToTop>\n    </Router>\n  );\n};\n"],"sourceRoot":""}