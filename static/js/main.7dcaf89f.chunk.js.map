{"version":3,"sources":["web/comps/menu.tsx","web/utils/errors.ts","web/utils/leveldb.ts","common/rdf.ts","web/utils/db.ts","web/utils/abstract_page.ts","common/models.ts","web/comps/topic_page.tsx","web/comps/note_page.tsx","web/comps/login_page.tsx","web/comps/app.tsx","web/serviceWorker.ts","index.tsx"],"names":["Menu","props","className","children","style","clear","reportError","err","opts","res","Promise","catch","e","console","error","DataFactory","N3","nested","db","name","sublevel","valueEncoding","dbList","dbNamespace","base","basedb","rdfStore","RdfStore","leveljs","dataFactory","levelup","namedNode","quad","prefixes","b","s","rdf","Object","keys","reduce","acc","k","v","remoteDbMemoized","getTopic","topicKey","get","md5","getNotes","topicId","a","notesLevelDB","getAll","list","map","n","text","addNote","getLastSeq","lastSeq","id","cuid","payload","_id","topic_id","seq","created_at","Date","now","trim","put","attemptNoteUpload","file","fn","at","configure","value","JSON","parse","localStorage","couchdb_target","sync","isConfigured","navigator","onLine","getDbTarget","remoteDb","getRemoteDb","info","uploadNotes","sourceDb","all","note","docId","doc","status","noteId","reason","topicNotes","del","existing","log","initialize","syncToLevelDB","importTuplesToQuadstore","importTopicsToLevelDB","updateLevelDB","allDocs","include_docs","startkey","endkey","rows","quads","row","filter","undefined","json","RdfString","subject","predicate","object","graph","update_seq","resultSequence","ops","flatMap","type","key","lastSlashItem","stripDoc","push","batch","changes","since","limit","batch_size","resultLastSeq","last_seq","results","length","change","startsWith","deleted","config","PouchDB","url","auth","Error","configsLevelDB","split","reverse","options","resolve","reject","createValueStream","on","data","_rev","NestedSectionListFieldNames","LastSectionListFieldNames","TodoListFieldNames","buildAbstractPage","title","sections","todoSection","frontSection","listSections","otherFieldsSection","deriveTitle","breadcrumbs","flat","listFieldNameDivs","divs","isShallow","listIsShallow","maybeLabelRefs","sectionDoc","topicSection","names","field","heading","p","appendQueueToPage","notes","forEach","item","queue","unshift","refToTextObject","topic","ref","label","maybeResolveSrc","src","srcNode","l","join","link","search","models","every","context","fragments","slice","contextPaths","fragment","index","TopicPage","state","page","setState","loadedFor","this","match","params","fetchContent","to","Breadcrumbs","i","simpleList","d","Component","buildAnchorElement","refLink","stringify","textItem","obj","mobile","document","documentElement","clientWidth","target","replace","indexOf","rel","href","encodeURIComponent","cssClass","encodeURI","NotePage","onKeyDown","which","metaKey","shiftKey","onSubmit","preventDefault","history","onChange","onClick","autoComplete","autoCapitalize","required","LoginPage","ScrollToTopInner","prevProps","location","pathname","window","scrollTo","ScrollToTop","withRouter","HistoryExporter","dbInitialize","Boolean","hostname","ReactDOM","render","basename","process","from","exact","path","component","getElementById","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.7dcaf89f.chunk.js","sourcesContent":["import React, { ReactNode } from 'react';\nimport './menu.css';\n\ninterface MenuProps {\n  children: ReactNode;\n}\n\nexport const Menu: React.FC<MenuProps> = props => {\n  return (\n    <div>\n      <ul className=\"menu\">{props.children}</ul>\n      <div style={{ clear: 'both' }}></div>\n    </div>\n  );\n};\n","export function reportError(err: any, opts?: any) {\n  if (typeof err === 'function') {\n    try {\n      const res = err();\n      if (res instanceof Promise) {\n        res.catch(reportError);\n      }\n    } catch (e) {\n      reportError(e);\n    }\n  } else {\n    if (!opts) {\n      opts = {};\n    }\n    opts.err = err;\n    console.error(opts);\n    console.error(err);\n  }\n}\n","import levelup, { LevelUp } from 'levelup';\nimport leveljs from 'level-js';\nimport sublevel from 'subleveldown';\nimport { RdfStore } from 'quadstore';\nimport * as N3 from 'n3';\n\nconst { DataFactory } = N3;\n\nexport function nested(db: LevelUp, name: string): LevelUp {\n  return sublevel(db, name, { valueEncoding: 'id' });\n}\n\nconst dbList = {} as { [key: string]: LevelUp };\nexport function dbNamespace(name: string): LevelUp {\n  if (!dbList[name]) {\n    dbList[name] = sublevel(base(), name, { valueEncoding: 'id' });\n  }\n\n  return dbList[name];\n}\n\nexport const rdfStore = new RdfStore(leveljs('rdf'), {\n  dataFactory: DataFactory,\n});\n\nlet basedb: LevelUp;\nexport function base(): LevelUp {\n  if (!basedb) {\n    basedb = levelup(leveljs('wiki'));\n  }\n\n  return basedb;\n}\n","import * as N3 from 'n3';\nimport * as QuadStore from 'quadstore';\nimport * as RdfString from 'rdf-string';\n\nconst { DataFactory } = N3;\nconst { namedNode, quad } = DataFactory;\n\nexport type Quad = N3.Quad;\nexport type StringQuad = QuadStore.StringQuad;\n\nexport interface GraphTrie {\n  [key: string]: StringQuad | GraphTrie;\n}\n\nexport function isObjectQuad(s: Quad | StringQuad): s is Quad {\n  return !isStringQuad(s);\n}\n\nexport function isStringQuad(\n  s: GraphTrie | Quad | StringQuad\n): s is StringQuad {\n  return (\n    typeof s.subject === 'string' &&\n    typeof s.predicate === 'string' &&\n    typeof s.object === 'string' &&\n    typeof s.graph === 'string'\n  );\n}\n\nexport function stringifyQuad(q: Quad | StringQuad): StringQuad {\n  if (isStringQuad(q)) {\n    return q;\n  } else {\n    return {\n      subject: RdfString.termToString(q.subject),\n      predicate: RdfString.termToString(q.predicate),\n      object: RdfString.termToString(q.object),\n      graph: RdfString.termToString(q.graph),\n    };\n  }\n}\nexport function unstringifyQuad(json: StringQuad): Quad {\n  return quad(\n    RdfString.stringToTerm(json.subject) as N3.Quad_Subject,\n    RdfString.stringToTerm(json.predicate) as N3.Quad_Predicate,\n    RdfString.stringToTerm(json.object) as N3.Quad_Object,\n    RdfString.stringToTerm(json.graph || '') as N3.Quad_Graph\n  );\n}\n\nexport const prefixes = {\n  b: 'https://curzonj.github.io/brain/#',\n  s: 'https://curzonj.github.io/rdf/schema#',\n  rdf: 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type',\n} as { [key: string]: string };\n\ninterface Prefixers {\n  [key: string]: (v: string) => N3.NamedNode;\n}\nexport const prefix: Prefixers = Object.keys(prefixes).reduce(\n  (acc, k: string) => {\n    acc[k] = (v: string) => namedNode(prefixes[k] + v);\n    return acc;\n  },\n  {} as Prefixers\n);\n\nexport function isNamedNode(t: N3.Term): t is N3.NamedNode {\n  return t.termType === 'NamedNode';\n}\n\nexport function rdfMatches(\n  candidate: Quad,\n  s: N3.Quad_Subject | null,\n  p: N3.Quad_Predicate | null,\n  o: N3.Quad_Object | null\n): boolean {\n  return (\n    (s === null || s.equals(candidate.subject)) &&\n    (p === null || p.equals(candidate.predicate)) &&\n    (o === null || o.equals(candidate.object))\n  );\n}\n\nexport function termId(\n  t: N3.NamedNode,\n  pre: string,\n  postfix: string = ''\n): string {\n  if (t.value.startsWith(pre)) {\n    return postfix + t.value.slice(pre.length);\n  }\n\n  return t.value;\n}\n\n// must match the type signature of N3.DataFactory.literal\nexport type ValidLiteralType = number | string;\nexport function isValidLiteralType(v: any): v is ValidLiteralType {\n  return typeof v === 'string' || typeof v === 'number';\n}\n","import PouchDB from 'pouchdb';\nimport md5 from 'blueimp-md5';\nimport cuid from 'cuid';\nimport { AbstractIteratorOptions, AbstractBatch } from 'abstract-leveldown';\nimport { LevelUp } from 'levelup';\n\nimport { reportError } from './errors';\nimport { dbNamespace, nested, base, rdfStore } from './leveldb';\nimport * as N3 from 'n3';\nimport * as models from '../../common/models';\nimport { unstringifyQuad } from '../../common/rdf';\n\nconst { DataFactory } = N3;\nconst { namedNode } = DataFactory;\n\nexport function getTopic(topicKey: string): Promise<models.Doc> {\n  return dbNamespace('topics').get(hash(topicKey));\n}\n\nexport async function pokeBear(topicId: string) {\n  const shortId = topicId.slice(1);\n\n  const tuples = await rdfStore.get({\n    subject: namedNode('https://curzonj.github.io/brain/#' + shortId),\n  });\n  console.log(tuples);\n}\nexport async function getNotes(topicId: string): Promise<string[]> {\n  const notesLevelDB = nested(dbNamespace('notes'), topicId);\n  const list = await getAll<models.Note>(notesLevelDB);\n\n  // merely by returning the entire list here, unsaved notes\n  // would gain the more link, but if you were to add a note\n  // onto that unsaved note, the sync would break\n  return list.map(n => n.text);\n}\n\nexport async function addNote(topicId: string, text: string) {\n  if (topicId === '/index') {\n    topicId = '/inbox';\n  }\n\n  const lastSeq = await getLastSeq();\n  const notesLevelDB = nested(dbNamespace('notes'), topicId);\n  const id = cuid();\n  const payload = {\n    _id: `$/queue/${topicId}/${id}`,\n    topic_id: topicId,\n    seq: lastSeq,\n    created_at: Date.now(),\n    id: `/${id}`,\n    text: text.trim(),\n  } as models.NewNote;\n\n  await notesLevelDB.put(id, payload);\n\n  // async but we won't wait for it\n  attemptNoteUpload(payload).catch(e =>\n    reportError(e, {\n      file: 'db',\n      fn: 'attemptNoteUpload',\n      at: 'catch',\n    })\n  );\n}\nexport async function configure(value: string) {\n  JSON.parse(value);\n  localStorage.couchdb_target = value;\n\n  await sync();\n}\n\nasync function isConfigured(): Promise<boolean> {\n  if (!navigator.onLine) {\n    return true;\n  }\n\n  const config = getDbTarget();\n  if (!config) {\n    return false;\n  }\n\n  const remoteDb = getRemoteDb();\n\n  try {\n    // TODO once I have a better idea of what errors from\n    // this can look like I'll delete the config and return\n    // false sometimes\n    await remoteDb.info();\n  } catch (e) {\n    reportError(e, {\n      at: 'db.isConfigured',\n    });\n  }\n\n  return true;\n}\n\nexport async function uploadNotes(sourceDb: PouchDB.Database) {\n  const notesLevelDB = dbNamespace('notes');\n  const list = await getAll<models.Note>(notesLevelDB);\n\n  await Promise.all(\n    list.map(async note => {\n      const docId = `$/queue/${note.topic_id}/${note.id}`;\n      const doc = {\n        _id: docId,\n        ...note,\n      } as models.NewNote;\n\n      const existing = await sourceDb\n        .get(docId)\n        .catch(async (e: PouchDB.Core.Error) => {\n          if (e.status !== 404) {\n            reportError(e, {\n              file: 'db',\n              fn: 'uploadNotes',\n              at: 'failure',\n              noteId: docId,\n            });\n\n            return e;\n          }\n\n          if (e.reason === 'deleted') {\n            // the translation between these IDs and couchdb is a\n            // little broken so it's easier to just delete them from levelDB\n            // when they are deleted from couchdb\n            const topicNotes = nested(dbNamespace('notes'), doc.topic_id);\n            await topicNotes.del(doc.id);\n\n            return e;\n          }\n\n          return;\n        });\n\n      if (existing) {\n        console.log({\n          file: 'db',\n          fn: 'uploadNotes',\n          at: 'skip',\n          doc,\n          existing,\n        });\n      } else {\n        await sourceDb.put(doc);\n      }\n    })\n  );\n}\n\nexport async function initialize(): Promise<boolean> {\n  const ready = await isConfigured();\n  if (!ready) {\n    return false;\n  }\n\n  await sync();\n\n  return true;\n}\n\nasync function sync() {\n  if (!navigator.onLine) {\n    return;\n  }\n\n  const remoteDb = getRemoteDb();\n\n  await syncToLevelDB(remoteDb);\n  await uploadNotes(remoteDb);\n}\n\nasync function syncToLevelDB(sourceDb: PouchDB.Database) {\n  const lastSeq = await getLastSeq();\n  if (!lastSeq) {\n    await importTuplesToQuadstore(sourceDb);\n    await importTopicsToLevelDB(sourceDb);\n  } else {\n    await updateLevelDB(sourceDb, lastSeq);\n  }\n}\n\nasync function importTuplesToQuadstore(sourceDb: PouchDB.Database) {\n  const { rows } = await sourceDb.allDocs<models.RdfDoc>({\n    include_docs: true,\n    startkey: `$/rdfHashes/`,\n    endkey: `$/rdfHashes/\\uFFF0`,\n  });\n  const quads = rows\n    .map(row => row.doc)\n    .filter(doc => doc !== undefined)\n    .map(doc => unstringifyQuad(doc as models.RdfDoc));\n\n  await rdfStore.put(quads);\n}\n\nasync function importTopicsToLevelDB(sourceDb: PouchDB.Database) {\n  const { rows, update_seq: resultSequence } = await sourceDb.allDocs<\n    models.Doc\n  >({\n    include_docs: true,\n    startkey: `$/topics/`,\n    endkey: `$/topics/\\uFFF0`,\n    update_seq: true,\n  });\n  const ops = rows.flatMap(({ doc }) => {\n    if (!doc) {\n      return [];\n    }\n\n    return {\n      type: 'put',\n      key: `!topics!${lastSlashItem(doc._id)}`,\n      value: stripDoc(doc),\n    } as AbstractBatch;\n  });\n\n  ops.push({ type: 'put', key: '!configs!lastSeq', value: resultSequence });\n\n  await base().batch(ops);\n}\n\nasync function updateLevelDB(\n  sourceDb: PouchDB.Database,\n  lastSeq: string | number\n): Promise<void> {\n  const { last_seq: resultLastSeq, results } = await sourceDb.changes<\n    models.CouchDocTypes\n  >({\n    include_docs: true,\n    since: lastSeq,\n    limit: 100,\n    batch_size: 100,\n  });\n\n  if (results.length === 0) {\n    return;\n  }\n\n  const ops: AbstractBatch[] = results.flatMap(change => {\n    if (change.id.startsWith('$/queue/')) {\n      // TODO currently this means that notes from other devices\n      // won't show up until they get synced on my laptop\n      return [];\n    } else if (change.deleted) {\n      return {\n        type: 'del',\n        key: `!topics!${lastSlashItem(change.id)}`,\n      };\n    } else if (change.doc) {\n      return {\n        type: 'put',\n        key: `!topics!${lastSlashItem(change.id)}`,\n        value: stripDoc(change.doc),\n      };\n    } else {\n      return [];\n    }\n  });\n\n  ops.push({ type: 'put', key: '!configs!lastSeq', value: resultLastSeq });\n\n  await base().batch(ops);\n\n  return updateLevelDB(sourceDb, resultLastSeq);\n}\n\nlet remoteDbMemoized: PouchDB.Database;\nfunction getRemoteDb() {\n  if (!remoteDbMemoized) {\n    const config = getDbTarget();\n    remoteDbMemoized = new PouchDB(config.url, config);\n  }\n\n  return remoteDbMemoized;\n}\n\nfunction getDbTarget() {\n  if (localStorage.couchdb_target) {\n    try {\n      const config = JSON.parse(localStorage.couchdb_target);\n      if (!config.url || !config.auth) {\n        throw new Error('Invalid db target config');\n      }\n\n      return config;\n    } catch (e) {\n      reportError(e);\n      delete localStorage.couchdb_target;\n    }\n  }\n\n  return null;\n}\n\nasync function getLastSeq() {\n  const configsLevelDB = dbNamespace('configs');\n  return configsLevelDB.get('lastSeq').catch((err: Error) => {});\n}\n\nasync function attemptNoteUpload(note: models.Note) {\n  if (!navigator.onLine) {\n    return;\n  }\n\n  const remoteDb = getRemoteDb();\n  await remoteDb.put(note);\n}\n\nexport function hash(s: string) {\n  return md5(s);\n}\n\nfunction lastSlashItem(docId: string) {\n  return reverseSlashes(docId)[0];\n}\n\nfunction reverseSlashes(v: string) {\n  return v.split('/').reverse();\n}\n\nfunction getAll<D>(\n  db: LevelUp,\n  options?: AbstractIteratorOptions\n): Promise<D[]> {\n  const list = [] as D[];\n  return new Promise((resolve, reject) => {\n    db.createValueStream(options)\n      .on('data', (data: D) => list.push(data))\n      .on('error', (err: Error) => reject(err))\n      .on('end', () => resolve(list));\n  });\n}\n\nfunction stripDoc<D extends {}>(doc: PouchDB.Core.ExistingDocument<D>): D {\n  delete doc._id;\n  delete doc._rev;\n\n  return doc;\n}\n","import * as db from './db';\nimport * as models from '../../common/models';\nimport { reportError } from './errors';\n\nconst NestedSectionListFieldNames = [\n  ['next', 'Next'],\n  ['later', 'Later'],\n  ['related', 'Related'],\n  ['mentions', 'Mentions'],\n  ['links', 'Links'],\n];\n\nconst LastSectionListFieldNames = [\n  ['related', 'Related'],\n  ['mentions', 'Mentions'],\n  ['links', 'Links'],\n  ['queue', 'Queue'],\n];\n\nconst TodoListFieldNames = [['next', 'Next'], ['later', 'Later']];\n\nexport interface AbstractPage {\n  title: string;\n  breadcrumbs?: any[];\n  sections: Section[];\n}\n\nexport interface Section {\n  title?: string;\n  text?: any;\n  list?: any[];\n  divs?: any[];\n}\n\nexport async function buildAbstractPage(\n  topicId: string\n): Promise<AbstractPage> {\n  const doc = await db.getTopic(topicId).catch(reportError);\n  if (!doc) {\n    return {\n      title: topicId,\n      sections: [\n        {\n          text: 'This page does not have any content yet.',\n        },\n      ],\n    };\n  }\n\n  const sections = await Promise.all([\n    todoSection(doc),\n    frontSection(doc),\n    listSections(doc),\n    otherFieldsSection(doc),\n  ]);\n\n  return {\n    title: deriveTitle(doc),\n    breadcrumbs: await breadcrumbs(doc),\n    sections: sections.flat(),\n  };\n}\n\nasync function todoSection(doc: models.Doc): Promise<Section | never[]> {\n  const divs = await listFieldNameDivs(TodoListFieldNames, doc);\n  if (divs.length === 0) {\n    return [];\n  }\n\n  return {\n    title: 'TODO',\n    divs,\n  };\n}\n\nasync function frontSection(doc: models.Doc) {\n  const { list } = doc;\n  const isShallow = listIsShallow(list);\n\n  if (!doc.text && !isShallow) {\n    return [];\n  }\n\n  return {\n    // TODO src, props\n    text: doc.text,\n    list: await maybeLabelRefs(isShallow ? undefined : doc.list),\n  } as Section;\n}\n\nasync function listSections(doc: models.Doc): Promise<Section[]> {\n  const { list } = doc;\n  if (!list || listIsShallow(list)) {\n    return [];\n  }\n\n  return Promise.all(\n    list.map(async (s: any) => {\n      if (typeof s === 'string' && s.startsWith('/')) {\n        const sectionDoc = await db.getTopic(s);\n        return topicSection(sectionDoc);\n      }\n\n      return {\n        text: s,\n      };\n    })\n  );\n}\n\nasync function topicSection(doc: models.Doc): Promise<Section> {\n  return {\n    title: deriveTitle(doc),\n    text: doc.text,\n    list: await maybeLabelRefs(doc.list),\n    divs: await listFieldNameDivs(NestedSectionListFieldNames, doc),\n  } as Section;\n}\n\nasync function listFieldNameDivs(names: string[][], doc: models.Doc) {\n  const p = await Promise.all(\n    names.map(async ([field, heading]) => {\n      if (!doc[field]) return [];\n      return [\n        {\n          heading,\n          list: await maybeLabelRefs(doc[field] as any[]),\n        },\n      ];\n    })\n  );\n\n  return p.flat();\n}\n\nasync function appendQueueToPage(doc: models.Doc) {\n  const notes = await db.getNotes(doc.id);\n  if (notes.length === 0) {\n    return;\n  }\n\n  notes.forEach(item => {\n    doc.queue = doc.queue || [];\n    doc.queue.unshift(item);\n  });\n}\n\nasync function otherFieldsSection(doc: models.Doc) {\n  await appendQueueToPage(doc);\n\n  const divs = await listFieldNameDivs(LastSectionListFieldNames, doc);\n  if (divs.length === 0) {\n    return [];\n  }\n\n  return {\n    divs,\n  };\n}\n\nasync function maybeLabelRefs(\n  list: undefined | any[]\n): Promise<undefined | any[]> {\n  if (!list || list.length === 0) return;\n\n  return Promise.all(\n    list.map(async v => {\n      // v could be an object from links\n      if (typeof v === 'string' && v.startsWith('/')) {\n        return refToTextObject(v);\n      }\n\n      return v;\n    })\n  );\n}\n\nasync function refToTextObject(topicId: string) {\n  const topic = await db.getTopic(topicId);\n  if (topic.title) {\n    return {\n      ref: topicId,\n      label: deriveTitle(topic),\n    };\n  } else if (!topic.text) {\n    return {\n      ref: topicId,\n      label: deriveTitle(topic),\n    };\n  } else {\n    return {\n      ref: topicId,\n      text: topic.text,\n      src: await maybeResolveSrc(topic.src),\n    };\n  }\n}\n\n// could be lots of things\nasync function maybeResolveSrc(src: undefined | models.Link) {\n  if (!src) return;\n  if (typeof src !== 'string') {\n    return src;\n  } else if (src.startsWith('/')) {\n    const srcNode = await db.getTopic(src);\n    return {\n      ref: src,\n      label: deriveTitle(srcNode),\n    };\n  } else {\n    return src;\n  }\n}\n\nfunction deriveTitle(n: models.Doc): string {\n  if (!n) return 'Missing Page';\n\n  let title = n.title || n.join;\n\n  if (!title && n.link) {\n    if (typeof n.link === 'string') {\n      title = n.link;\n    } else if (models.isLabeledLink(n.link)) {\n      title = n.link.link;\n    } else if (models.isSearchLink(n.link)) {\n      title = n.link.search;\n    }\n  }\n\n  return title || 'Note';\n}\n\nfunction listIsShallow(list: undefined | any[]): boolean {\n  return (\n    list !== undefined &&\n    list.every(s => typeof s === 'string' && !s.startsWith('/'))\n  );\n}\n\nasync function breadcrumbs(doc: models.Doc) {\n  if (!doc.context) return undefined;\n\n  // This dates back to the deeply nested path style keys used\n  // as contexts\n  const fragments: string[] = doc.context.split('/').slice(1);\n  const contextPaths = fragments.map(\n    (fragment, index) => `/${fragments.slice(0, index + 1).join('/')}`\n  );\n\n  return maybeLabelRefs(contextPaths);\n}\n","import PouchDB from 'pouchdb';\nimport { StringQuad, ValidLiteralType } from './rdf';\n\nexport interface Note {\n  id: string;\n  text: string;\n  created_at: number;\n  seq: number | string;\n  topic_id: string;\n}\n\nexport interface ShortDoc {\n  created_at?: number;\n  title?: string;\n  join?: string;\n  text?: string;\n  src?: Link;\n  link?: Link;\n  context?: string;\n  topic_id?: string;\n  queue?: string[];\n  list?: string[];\n  links?: LinkList;\n  props?: DumbProps;\n  patches?: DocChangeEntry[];\n  [key: string]: DocValueTypes;\n}\n\nexport interface Doc extends ShortDoc {\n  id: string;\n  created_at?: number;\n  [key: string]: DocValueTypes;\n}\n\nexport interface DumbProps {\n  quanity?: string;\n  author?: string;\n  [key: string]: string | undefined;\n}\n\nexport interface DocChangeEntry {\n  op: 'add' | 'remove';\n  field: string;\n  value: ValidLiteralType;\n}\n\nexport type LinkList = Link[];\nexport type Link = string | LabeledLink | SearchLink;\nexport interface SearchLink {\n  search: string;\n}\nexport interface LabeledLink {\n  title: string;\n  link: string;\n}\nexport type EditorArrayItemTypes = Link | MaybeLabeledRef;\nexport type DocArrayValueTypes = string[] | LinkList;\nexport type RegularDocValueTypes =\n  | string[]\n  | string\n  | number\n  | undefined\n  | Link\n  | LinkList\n  | DumbProps;\nexport type DocValueTypes = RegularDocValueTypes | DocChangeEntry[];\n\nexport type ExistingDoc = PouchDB.Core.ExistingDocument<Doc>;\nexport type DocUpdate = PouchDB.Core.PutDocument<Doc> & PouchDB.Core.IdMeta;\nexport type RdfDoc = StringQuad;\nexport type CouchDocTypes = Doc | RdfDoc | Note;\nexport type NewNote = PouchDB.Core.PutDocument<Note>;\n\nexport interface EditorDoc {\n  text?: string;\n  queue?: RefList;\n  links?: LinkList;\n  [key: string]: EditorValueTypes;\n}\n\nexport interface LabeledRef {\n  label: string;\n  ref: string;\n}\n\nexport type EditorValueTypes = RegularDocValueTypes | RefList;\nexport type RefList = MaybeLabeledRef[];\nexport type MaybeLabeledRef = string | LabeledRef;\nexport type EditorStructure = Record<string, EditorDoc>;\n\nexport const StorageFields = ['_rev', '_id', '_deleted', 'id', 'patches'];\nexport function removeStorageAttributes(\n  doc: ExistingDoc | DocUpdate\n): ShortDoc {\n  const clone = { ...doc } as any;\n\n  StorageFields.forEach(k => {\n    delete clone[k];\n  });\n\n  return clone as ShortDoc;\n}\n\nexport function isStorageField(k: string) {\n  return StorageFields.indexOf(k) > -1;\n}\n\nexport function isPatches(k: string, v: DocValueTypes): v is DocChangeEntry[] {\n  return Array.isArray(v) && k === 'patches';\n}\n\nexport function isDocArrayField(\n  k: string,\n  v: DocValueTypes\n): v is DocArrayValueTypes {\n  return Array.isArray(v) && k !== 'patches';\n}\n\nexport function isLabeledRef(l: any): l is LabeledRef {\n  if (typeof l === 'string') {\n    return false;\n  }\n\n  return !!(l as LabeledRef).ref;\n}\n\nexport function isSearchLink(l: any): l is SearchLink {\n  if (typeof l === 'string') {\n    return false;\n  }\n\n  return !!(l as SearchLink).search;\n}\n\nexport function isLabeledLink(l: any): l is LabeledLink {\n  if (typeof l === 'string') {\n    return false;\n  }\n\n  return !!(l as LabeledLink).link;\n}\n\nexport function isProps(k: string, o: DocValueTypes): o is DumbProps {\n  return k === 'props';\n}\n","import React, { Component } from 'react';\nimport { RouteComponentProps } from 'react-router';\nimport { Link } from 'react-router-dom';\nimport { Menu } from './menu';\nimport './topic_page.css';\nimport {\n  buildAbstractPage,\n  AbstractPage,\n  Section,\n} from '../utils/abstract_page';\nimport { reportError } from '../utils/errors';\n\nexport type TopicPageProps = RouteComponentProps<{\n  topicId: string;\n}>;\n\ninterface TopicPageState {\n  page?: AbstractPage;\n  loadedFor?: string;\n}\n\nexport class TopicPage extends Component<TopicPageProps, TopicPageState> {\n  constructor(props: TopicPageProps) {\n    super(props);\n    this.state = {};\n  }\n\n  componentWillUnmount() {}\n\n  fetchContent(topicId: string) {\n    reportError(async () => {\n      // TODO find a way to cancel this from componentWillUnmount\n      const page = await buildAbstractPage(`/${topicId}`);\n      this.setState({\n        loadedFor: topicId,\n        page,\n      });\n    });\n  }\n\n  render() {\n    const { topicId } = this.props.match.params;\n\n    if (this.state.loadedFor !== topicId) {\n      this.fetchContent(topicId);\n    }\n\n    return (\n      <div className=\"topicPage\">\n        <Menu>\n          <li>\n            <Link to=\"/index\">index</Link>\n          </li>\n          <li>\n            <Link to={'/add_note/' + topicId}>add note</Link>\n          </li>\n        </Menu>\n\n        <div className=\"header\">\n          {this.state.page && (\n            <Breadcrumbs breadcrumbs={this.state.page.breadcrumbs} />\n          )}\n          <h1 className=\"title\">\n            {this.state.page ? this.state.page.title : topicId}\n          </h1>\n        </div>\n\n        {this.state.page ? (\n          renderSections(this.state.page.sections)\n        ) : (\n          <section>\n            <p>Loading...</p>\n          </section>\n        )}\n      </div>\n    );\n  }\n}\n\nfunction renderSections(sections: Section[]) {\n  return sections.map((s, i) => {\n    return (\n      <section key={i}>\n        {s.title && <h2 className=\"title\">{s.title}</h2>}\n        {s.text && <p>{s.text}</p>}\n        {s.list && simpleList(s.list)}\n        {s.divs && sectionDivs(s.divs)}\n      </section>\n    );\n  });\n}\n\nfunction sectionDivs(divs: any[]) {\n  return divs.map((d, i) => {\n    return (\n      <div key={i}>\n        {d.heading && <h3 className=\"title\">{d.heading}</h3>}\n        {simpleList(d.list)}\n      </div>\n    );\n  });\n}\n\nfunction simpleList(list: any[]) {\n  return (\n    <ul>\n      {list.map((s, i) => (\n        <li key={i}>{textItem(s)}</li>\n      ))}\n    </ul>\n  );\n}\n\nfunction Breadcrumbs(props: { breadcrumbs: undefined | any[] }) {\n  return <></>;\n}\n\nfunction textItem(item: any) {\n  if (typeof item === 'string') {\n    if (item.startsWith('http')) {\n      return buildAnchorElement(item);\n    }\n    return <p>{item}</p>;\n  } else if (item.link || item.search) {\n    return buildAnchorElement(item);\n  } else if (item.label) {\n    return refLink(item.ref, item.label);\n  } else {\n    return (\n      <p>\n        {item.text}\n        {renderSrc(item.src)}({refLink(item.ref, 'more', 'moreLink')})\n      </p>\n    );\n  }\n}\n\nfunction renderSrc(src: any) {\n  if (!src) {\n    return undefined;\n  } else if (typeof src === 'string') {\n    return <span>- ${src}</span>;\n  } else if (src.ref) {\n    return refLink(src.ref, src.label);\n  } else {\n    // TODO replace this, it could be a labeled link\n    return <pre>{JSON.stringify(src)}</pre>;\n  }\n}\n\nfunction buildAnchorElement(obj: any) {\n  const mobile = document.documentElement.clientWidth < 800;\n\n  if (typeof obj === 'string' || obj.link) {\n    let target = obj;\n    let text = obj;\n\n    if (typeof obj !== 'string') {\n      target = obj.link;\n      text = obj.title || obj.link;\n    }\n\n    if (text.startsWith('https://en.wikipedia.org/wiki')) {\n      text = `Wikipedia: ${text\n        .replace('https://en.wikipedia.org/wiki/', '')\n        .replace(/_/g, ' ')}`;\n    } else if (text.indexOf('pinboard.in/u:curzonj/') !== -1) {\n      text = `Pinboard: ${text\n        .replace(/https?:\\/\\/pinboard.in\\/u:curzonj\\//, '')\n        .split('/')\n        .filter((l: string) => l !== '')\n        .flatMap((l: string) => l.replace(/^t:/, ''))\n        .join(', ')}`;\n      target = target.replace(/^http:\\/\\//, 'https://');\n      if (mobile) {\n        target = target.replace('pinboard.in', 'm.pinboard.in');\n      }\n    }\n\n    return (\n      <a target=\"_blank\" rel=\"noopener noreferrer\" href={target}>\n        {text}\n      </a>\n    );\n  }\n  if (obj.search) {\n    return (\n      <a\n        target=\"_blank\"\n        rel=\"noopener noreferrer\"\n        href={'https://google.com/search?q=' + encodeURIComponent(obj.search)}\n      >\n        Google: {obj.search}\n      </a>\n    );\n  }\n\n  return undefined;\n}\n\nfunction refLink(link: string, text: string, cssClass: string = 'refLink') {\n  return (\n    <Link className={cssClass} to={encodeURI(link)}>\n      {text || link}\n    </Link>\n  );\n}\n","import React, { Component } from 'react';\nimport { Menu } from './menu';\nimport { TopicPageProps } from './topic_page';\nimport { reportError } from '../utils/errors';\nimport * as db from '../utils/db';\n\nexport class NotePage extends Component<TopicPageProps, { value: string }> {\n  constructor(props: TopicPageProps) {\n    super(props);\n    this.state = { value: '' };\n  }\n\n  onKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {\n    if (e.which === 13 && (e.metaKey || e.shiftKey)) this.onSubmit(e);\n  };\n\n  onSubmit = (e: React.SyntheticEvent) => {\n    e.preventDefault();\n\n    reportError(async () => {\n      const { topicId } = this.props.match.params;\n      await db.addNote(topicId, this.state.value);\n      this.props.history.push(topicId);\n    });\n  };\n\n  onChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {\n    if (e && e.target) {\n      this.setState({ value: e.target.value });\n    }\n  };\n\n  render() {\n    const { topicId } = this.props.match.params;\n\n    return (\n      <>\n        <Menu>\n          <li>\n            <button\n              type=\"button\"\n              className=\"link-button\"\n              onClick={this.onSubmit}\n            >\n              done\n            </button>\n          </li>\n        </Menu>\n        <h2>{topicId}</h2>\n        <form>\n          <textarea\n            onKeyDown={this.onKeyDown}\n            autoComplete=\"on\"\n            autoCapitalize=\"sentences\"\n            required\n            onChange={this.onChange}\n            value={this.state.value}\n          ></textarea>\n        </form>\n      </>\n    );\n  }\n}\n","import React, { Component } from 'react';\nimport { RouteComponentProps } from 'react-router';\nimport { Menu } from './menu';\nimport { reportError } from '../utils/errors';\nimport * as db from '../utils/db';\n\nexport class LoginPage extends Component<\n  RouteComponentProps,\n  { value: string }\n> {\n  constructor(props: RouteComponentProps) {\n    super(props);\n    this.state = { value: '' };\n  }\n\n  onKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {\n    if (e.which === 13 && (e.metaKey || e.shiftKey)) this.onSubmit(e);\n  };\n\n  onSubmit = (e: React.SyntheticEvent) => {\n    e.preventDefault();\n\n    reportError(async () => {\n      await db.configure(this.state.value);\n      this.props.history.push('/index');\n    });\n  };\n\n  onChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {\n    if (e && e.target) {\n      this.setState({ value: e.target.value });\n    }\n  };\n\n  render() {\n    return (\n      <>\n        <Menu>\n          <li>\n            <button\n              type=\"button\"\n              className=\"link-button\"\n              onClick={this.onSubmit}\n            >\n              done\n            </button>\n          </li>\n        </Menu>\n\n        <div className=\"header\">\n          <h1 className=\"title\">Enter the configuration</h1>\n        </div>\n\n        <form>\n          <textarea\n            onKeyDown={this.onKeyDown}\n            autoComplete=\"on\"\n            autoCapitalize=\"sentences\"\n            required\n            onChange={this.onChange}\n            value={this.state.value}\n          ></textarea>\n        </form>\n      </>\n    );\n  }\n}\n","import React, { Component } from 'react';\nimport {\n  BrowserRouter as Router,\n  Route,\n  Switch,\n  Redirect,\n} from 'react-router-dom';\nimport { withRouter, RouteComponentProps } from 'react-router';\nimport './app.css';\nimport { TopicPage } from './topic_page';\nimport { NotePage } from './note_page';\nimport { LoginPage } from './login_page';\nimport { initialize as dbInitialize } from '../utils/db';\nimport { reportError } from '../utils/errors';\n\nclass ScrollToTopInner extends Component<RouteComponentProps> {\n  componentDidUpdate(prevProps: RouteComponentProps) {\n    if (this.props.location.pathname !== prevProps.location.pathname) {\n      window.scrollTo(0, 0);\n    }\n  }\n\n  render() {\n    return this.props.children;\n  }\n}\nconst ScrollToTop = withRouter(ScrollToTopInner);\n\nconst HistoryExporter = withRouter((props: RouteComponentProps) => {\n  reportError(async () => {\n    const ok = await dbInitialize();\n    if (!ok) {\n      props.history.push('/login');\n    }\n  });\n\n  return <></>;\n});\n\nexport const App: React.FC = () => {\n  return (\n    <Router basename={process.env.PUBLIC_URL}>\n      <HistoryExporter />\n\n      <ScrollToTop>\n        <Switch>\n          <Redirect from=\"/\" to=\"/index\" exact />\n          <Route path=\"/login\" component={LoginPage} />\n          <Route path=\"/add_note/:topicId\" component={NotePage} />\n          <Route path=\"/:topicId\" component={TopicPage} />\n        </Switch>\n      </ScrollToTop>\n    </Router>\n  );\n};\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './web/index.css';\nimport { App } from './web/comps/app';\nimport * as serviceWorker from './web/serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}