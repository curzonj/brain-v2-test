{"version":3,"sources":["web/comps/menu.tsx","web/utils/errors.ts","web/utils/leveldb.ts","common/rdf.ts","web/utils/db.ts","web/utils/abstract_page.ts","common/models.ts","web/comps/topic_page.tsx","web/comps/note_page.tsx","web/comps/login_page.tsx","web/comps/app.tsx","web/serviceWorker.ts","index.tsx"],"names":["Menu","props","className","children","style","clear","reportError","err","opts","res","Promise","catch","e","console","error","DataFactory","N3","nested","db","name","sublevel","valueEncoding","dbList","dbNamespace","base","basedb","rdfStore","RdfStore","leveljs","dataFactory","levelup","namedNode","quad","prefixes","b","s","rdf","Object","keys","reduce","acc","k","v","remoteDbMemoized","localDbMemoized","getTopic","topicKey","get","md5","getNotes","topicId","a","notesLevelDB","getAll","list","map","n","text","configure","value","JSON","parse","localStorage","couchdb_target","sync","isConfigured","navigator","onLine","getDbTarget","remoteDb","getRemoteDb","info","at","uploadNotes","sourceDb","all","note","docId","topic_id","id","doc","_id","status","file","fn","noteId","reason","topicNotes","del","existing","log","put","initialize","localDb","getLocalDb","syncToLevelDB","getLastSeq","lastSeq","importTuplesToQuadstore","importTopicsToLevelDB","updateLevelDB","allDocs","include_docs","startkey","endkey","rows","quads","row","filter","undefined","json","RdfString","subject","predicate","object","graph","update_seq","resultSequence","ops","flatMap","type","key","lastSlashItem","stripDoc","push","batch","changes","since","limit","batch_size","resultLastSeq","last_seq","results","length","change","startsWith","deleted","config","PouchDB","url","auto_compaction","auth","Error","configsLevelDB","split","reverse","options","resolve","reject","createValueStream","on","data","_rev","NestedSectionListFieldNames","LastSectionListFieldNames","TodoListFieldNames","buildAbstractPage","title","sections","todoSection","frontSection","listSections","otherFieldsSection","deriveTitle","breadcrumbs","flat","listFieldNameDivs","divs","isShallow","listIsShallow","maybeLabelRefs","sectionDoc","topicSection","names","field","heading","p","appendQueueToPage","notes","forEach","item","queue","unshift","refToTextObject","topic","ref","label","maybeResolveSrc","src","srcNode","l","join","link","search","models","every","context","fragments","slice","contextPaths","fragment","index","TopicPage","state","page","setState","loadedFor","this","match","params","fetchContent","to","Breadcrumbs","i","simpleList","d","Component","buildAnchorElement","refLink","stringify","textItem","obj","mobile","document","documentElement","clientWidth","target","replace","indexOf","rel","href","encodeURIComponent","cssClass","encodeURI","NotePage","onClick","hello","LoginPage","onKeyDown","which","metaKey","shiftKey","onSubmit","preventDefault","history","onChange","autoComplete","autoCapitalize","required","ScrollToTopInner","prevProps","location","pathname","window","scrollTo","ScrollToTop","withRouter","HistoryExporter","dbInitialize","Boolean","hostname","ReactDOM","render","basename","process","URL","from","exact","path","component","getElementById","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.613e4c02.chunk.js","sourcesContent":["import React, { ReactNode } from 'react';\nimport './menu.css';\n\ninterface MenuProps {\n  children: ReactNode;\n}\n\nexport const Menu: React.FC<MenuProps> = props => {\n  return (\n    <div>\n      <ul className=\"menu\">{props.children}</ul>\n      <div style={{ clear: 'both' }}></div>\n    </div>\n  );\n};\n","export function reportError(err: any, opts?: any) {\n  if (typeof err === 'function') {\n    try {\n      const res = err();\n      if (res instanceof Promise) {\n        res.catch(reportError);\n      }\n    } catch (e) {\n      reportError(e);\n    }\n  } else {\n    if (!opts) {\n      opts = {};\n    }\n    opts.err = err;\n    console.error(opts);\n    console.error(err);\n  }\n}\n","import levelup, { LevelUp } from 'levelup';\nimport leveljs from 'level-js';\nimport sublevel from 'subleveldown';\nimport { RdfStore } from 'quadstore';\nimport * as N3 from 'n3';\n\nconst { DataFactory } = N3;\n\nexport function nested(db: LevelUp, name: string): LevelUp {\n  return sublevel(db, name, { valueEncoding: 'id' });\n}\n\nconst dbList = {} as { [key: string]: LevelUp };\nexport function dbNamespace(name: string): LevelUp {\n  if (!dbList[name]) {\n    dbList[name] = sublevel(base(), name, { valueEncoding: 'id' });\n  }\n\n  return dbList[name];\n}\n\nexport const rdfStore = new RdfStore(leveljs('rdf'), {\n  dataFactory: DataFactory,\n});\n\nlet basedb: LevelUp;\nexport function base(): LevelUp {\n  if (!basedb) {\n    basedb = levelup(leveljs('wiki'));\n  }\n\n  return basedb;\n}\n","import * as N3 from 'n3';\nimport * as QuadStore from 'quadstore';\nimport * as RdfString from 'rdf-string';\n\nconst { DataFactory } = N3;\nconst { namedNode, quad } = DataFactory;\n\nexport type Quad = N3.Quad;\nexport type StringQuad = QuadStore.StringQuad;\n\nexport interface GraphTrie {\n  [key: string]: StringQuad | GraphTrie;\n}\n\nexport function isObjectQuad(s: Quad | StringQuad): s is Quad {\n  return !isStringQuad(s);\n}\n\nexport function isStringQuad(\n  s: GraphTrie | Quad | StringQuad\n): s is StringQuad {\n  return (\n    typeof s.subject === 'string' &&\n    typeof s.predicate === 'string' &&\n    typeof s.object === 'string' &&\n    typeof s.graph === 'string'\n  );\n}\n\nexport function stringifyQuad(q: Quad | StringQuad): StringQuad {\n  if (isStringQuad(q)) {\n    return q;\n  } else {\n    return {\n      subject: RdfString.termToString(q.subject),\n      predicate: RdfString.termToString(q.predicate),\n      object: RdfString.termToString(q.object),\n      graph: RdfString.termToString(q.graph),\n    };\n  }\n}\nexport function unstringifyQuad(json: StringQuad): Quad {\n  return quad(\n    RdfString.stringToTerm(json.subject) as N3.Quad_Subject,\n    RdfString.stringToTerm(json.predicate) as N3.Quad_Predicate,\n    RdfString.stringToTerm(json.object) as N3.Quad_Object,\n    RdfString.stringToTerm(json.graph || '') as N3.Quad_Graph\n  );\n}\n\nexport const prefixes = {\n  b: 'https://curzonj.github.io/brain/#',\n  s: 'https://curzonj.github.io/rdf/schema#',\n  rdf: 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type',\n} as { [key: string]: string };\n\ninterface Prefixers {\n  [key: string]: (v: string) => N3.NamedNode;\n}\nexport const prefix: Prefixers = Object.keys(prefixes).reduce(\n  (acc, k: string) => {\n    acc[k] = (v: string) => namedNode(prefixes[k] + v);\n    return acc;\n  },\n  {} as Prefixers\n);\n\nexport function isNamedNode(t: N3.Term): t is N3.NamedNode {\n  return t.termType === 'NamedNode';\n}\n\nexport function rdfMatches(\n  candidate: Quad,\n  s: N3.Quad_Subject | null,\n  p: N3.Quad_Predicate | null,\n  o: N3.Quad_Object | null\n): boolean {\n  return (\n    (s === null || s.equals(candidate.subject)) &&\n    (p === null || p.equals(candidate.predicate)) &&\n    (o === null || o.equals(candidate.object))\n  );\n}\n\nexport function termId(\n  t: N3.NamedNode,\n  pre: string,\n  postfix: string = ''\n): string {\n  if (t.value.startsWith(pre)) {\n    return postfix + t.value.slice(pre.length);\n  }\n\n  return t.value;\n}\n\n// must match the type signature of N3.DataFactory.literal\nexport type ValidLiteralType = number | string;\nexport function isValidLiteralType(v: any): v is ValidLiteralType {\n  return typeof v === 'string' || typeof v === 'number';\n}\n","import PouchDB from 'pouchdb';\nimport md5 from 'blueimp-md5';\nimport cuid from 'cuid';\nimport { AbstractIteratorOptions, AbstractBatch } from 'abstract-leveldown';\nimport { LevelUp } from 'levelup';\n\nimport { reportError } from './errors';\nimport { dbNamespace, nested, base, rdfStore } from './leveldb';\nimport * as N3 from 'n3';\nimport * as models from '../../common/models';\nimport { unstringifyQuad } from '../../common/rdf';\n\nconst { DataFactory } = N3;\nconst { namedNode } = DataFactory;\n\nexport function getTopic(topicKey: string): Promise<models.Doc> {\n  return dbNamespace('topics').get(hash(topicKey));\n}\n\nexport async function pokeBear(topicId: string) {\n  const shortId = topicId.slice(1);\n\n  const tuples = await rdfStore.get({\n    subject: namedNode('https://curzonj.github.io/brain/#' + shortId),\n  });\n  console.log(tuples);\n}\nexport async function getNotes(topicId: string): Promise<string[]> {\n  const notesLevelDB = nested(dbNamespace('notes'), topicId);\n  const list = await getAll<models.Note>(notesLevelDB);\n\n  // merely by returning the entire list here, unsaved notes\n  // would gain the more link, but if you were to add a note\n  // onto that unsaved note, the sync would break\n  return list.map(n => n.text);\n}\n\nexport async function addNote(topicId: string, text: string) {\n  if (topicId === '/index') {\n    topicId = '/inbox';\n  }\n\n  const lastSeq = await getLastSeq();\n  const notesLevelDB = nested(dbNamespace('notes'), topicId);\n  const id = cuid();\n  const payload = {\n    _id: `$/queue/${topicId}/${id}`,\n    topic_id: topicId,\n    seq: lastSeq,\n    created_at: Date.now(),\n    id: `/${id}`,\n    text: text.trim(),\n  } as models.NewNote;\n\n  await notesLevelDB.put(id, payload);\n\n  // async but we won't wait for it\n  attemptNoteUpload(payload).catch(e =>\n    reportError(e, {\n      file: 'db',\n      fn: 'attemptNoteUpload',\n      at: 'catch',\n    })\n  );\n}\nexport async function configure(value: string) {\n  JSON.parse(value);\n  localStorage.couchdb_target = value;\n\n  await sync();\n}\n\nasync function isConfigured(): Promise<boolean> {\n  if (!navigator.onLine) {\n    return true;\n  }\n\n  const config = getDbTarget();\n  if (!config) {\n    return false;\n  }\n\n  const remoteDb = getRemoteDb();\n\n  try {\n    // TODO once I have a better idea of what errors from\n    // this can look like I'll delete the config and return\n    // false sometimes\n    await remoteDb.info();\n  } catch (e) {\n    reportError(e, {\n      at: 'db.isConfigured',\n    });\n  }\n\n  return true;\n}\n\nexport async function uploadNotes(sourceDb: PouchDB.Database) {\n  const notesLevelDB = dbNamespace('notes');\n  const list = await getAll<models.Note>(notesLevelDB);\n\n  await Promise.all(\n    list.map(async note => {\n      const docId = `$/queue/${note.topic_id}/${note.id}`;\n      const doc = {\n        _id: docId,\n        ...note,\n      } as models.NewNote;\n\n      const existing = await sourceDb\n        .get(docId)\n        .catch(async (e: PouchDB.Core.Error) => {\n          if (e.status !== 404) {\n            reportError(e, {\n              file: 'db',\n              fn: 'uploadNotes',\n              at: 'failure',\n              noteId: docId,\n            });\n\n            return e;\n          }\n\n          if (e.reason === 'deleted') {\n            // the translation between these IDs and couchdb is a\n            // little broken so it's easier to just delete them from levelDB\n            // when they are deleted from couchdb\n            const topicNotes = nested(dbNamespace('notes'), doc.topic_id);\n            await topicNotes.del(doc.id);\n\n            return e;\n          }\n\n          return;\n        });\n\n      if (existing) {\n        console.log({\n          file: 'db',\n          fn: 'uploadNotes',\n          at: 'skip',\n          doc,\n          existing,\n        });\n      } else {\n        await sourceDb.put(doc);\n      }\n    })\n  );\n}\n\nexport async function initialize(): Promise<boolean> {\n  const ready = await isConfigured();\n  if (!ready) {\n    return false;\n  }\n\n  await sync();\n\n  return true;\n}\n\nasync function sync() {\n  if (!navigator.onLine) {\n    return;\n  }\n\n  const remoteDb = getRemoteDb();\n  const localDb = getLocalDb();\n\n  localDb.sync(remoteDb);\n\n  await syncToLevelDB(localDb);\n  await uploadNotes(localDb);\n}\n\nasync function syncToLevelDB(sourceDb: PouchDB.Database) {\n  const lastSeq = await getLastSeq();\n  if (!lastSeq) {\n    await importTuplesToQuadstore(sourceDb);\n    await importTopicsToLevelDB(sourceDb);\n  } else {\n    await updateLevelDB(sourceDb, lastSeq);\n  }\n}\n\nasync function importTuplesToQuadstore(sourceDb: PouchDB.Database) {\n  const { rows } = await sourceDb.allDocs<models.RdfDoc>({\n    include_docs: true,\n    startkey: `$/rdfHashes/`,\n    endkey: `$/rdfHashes/\\uFFF0`,\n  });\n  const quads = rows\n    .map(row => row.doc)\n    .filter(doc => doc !== undefined)\n    .map(doc => unstringifyQuad(doc as models.RdfDoc));\n\n  await rdfStore.put(quads);\n}\n\nasync function importTopicsToLevelDB(sourceDb: PouchDB.Database) {\n  const { rows, update_seq: resultSequence } = await sourceDb.allDocs<\n    models.Doc\n  >({\n    include_docs: true,\n    startkey: `$/topics/`,\n    endkey: `$/topics/\\uFFF0`,\n    update_seq: true,\n  });\n  const ops = rows.flatMap(({ doc }) => {\n    if (!doc) {\n      return [];\n    }\n\n    return {\n      type: 'put',\n      key: `!topics!${lastSlashItem(doc._id)}`,\n      value: stripDoc(doc),\n    } as AbstractBatch;\n  });\n\n  ops.push({ type: 'put', key: '!configs!lastSeq', value: resultSequence });\n\n  await base().batch(ops);\n}\n\nasync function updateLevelDB(\n  sourceDb: PouchDB.Database,\n  lastSeq: string | number\n): Promise<void> {\n  const { last_seq: resultLastSeq, results } = await sourceDb.changes<\n    models.CouchDocTypes\n  >({\n    include_docs: true,\n    since: lastSeq,\n    limit: 100,\n    batch_size: 100,\n  });\n\n  if (results.length === 0) {\n    return;\n  }\n\n  const ops: AbstractBatch[] = results.flatMap(change => {\n    if (change.id.startsWith('$/queue/')) {\n      // TODO currently this means that notes from other devices\n      // won't show up until they get synced on my laptop\n      return [];\n    } else if (change.deleted) {\n      return {\n        type: 'del',\n        key: `!topics!${lastSlashItem(change.id)}`,\n      };\n    } else if (change.doc) {\n      return {\n        type: 'put',\n        key: `!topics!${lastSlashItem(change.id)}`,\n        value: stripDoc(change.doc),\n      };\n    } else {\n      return [];\n    }\n  });\n\n  ops.push({ type: 'put', key: '!configs!lastSeq', value: resultLastSeq });\n\n  await base().batch(ops);\n\n  return updateLevelDB(sourceDb, resultLastSeq);\n}\n\nlet remoteDbMemoized: PouchDB.Database;\nfunction getRemoteDb() {\n  if (!remoteDbMemoized) {\n    const config = getDbTarget();\n    remoteDbMemoized = new PouchDB(config.url, config);\n  }\n\n  return remoteDbMemoized;\n}\n\nlet localDbMemoized: PouchDB.Database;\nfunction getLocalDb() {\n  if (!localDbMemoized) {\n    localDbMemoized = new PouchDB('wiki', {\n      auto_compaction: true,\n    });\n  }\n\n  return localDbMemoized;\n}\n\nfunction getDbTarget() {\n  if (localStorage.couchdb_target) {\n    try {\n      const config = JSON.parse(localStorage.couchdb_target);\n      if (!config.url || !config.auth) {\n        throw new Error('Invalid db target config');\n      }\n\n      return config;\n    } catch (e) {\n      reportError(e);\n      delete localStorage.couchdb_target;\n    }\n  }\n\n  return null;\n}\n\nasync function getLastSeq() {\n  const configsLevelDB = dbNamespace('configs');\n  return configsLevelDB.get('lastSeq').catch((err: Error) => {});\n}\n\nasync function attemptNoteUpload(note: models.Note) {\n  const localDb = getLocalDb();\n  await localDb.put(note);\n\n  if (!navigator.onLine) {\n    return;\n  }\n\n  const remoteDb = getRemoteDb();\n  localDb.sync(remoteDb);\n}\n\nexport function hash(s: string) {\n  return md5(s);\n}\n\nfunction lastSlashItem(docId: string) {\n  return reverseSlashes(docId)[0];\n}\n\nfunction reverseSlashes(v: string) {\n  return v.split('/').reverse();\n}\n\nfunction getAll<D>(\n  db: LevelUp,\n  options?: AbstractIteratorOptions\n): Promise<D[]> {\n  const list = [] as D[];\n  return new Promise((resolve, reject) => {\n    db.createValueStream(options)\n      .on('data', (data: D) => list.push(data))\n      .on('error', (err: Error) => reject(err))\n      .on('end', () => resolve(list));\n  });\n}\n\nfunction stripDoc<D extends {}>(doc: PouchDB.Core.ExistingDocument<D>): D {\n  delete doc._id;\n  delete doc._rev;\n\n  return doc;\n}\n","import * as db from './db';\nimport * as models from '../../common/models';\nimport { reportError } from './errors';\n\nconst NestedSectionListFieldNames = [\n  ['next', 'Next'],\n  ['later', 'Later'],\n  ['related', 'Related'],\n  ['mentions', 'Mentions'],\n  ['links', 'Links'],\n];\n\nconst LastSectionListFieldNames = [\n  ['related', 'Related'],\n  ['mentions', 'Mentions'],\n  ['links', 'Links'],\n  ['queue', 'Queue'],\n];\n\nconst TodoListFieldNames = [['next', 'Next'], ['later', 'Later']];\n\nexport interface AbstractPage {\n  title: string;\n  breadcrumbs?: any[];\n  sections: Section[];\n}\n\nexport interface Section {\n  title?: string;\n  text?: any;\n  list?: any[];\n  divs?: any[];\n}\n\nexport async function buildAbstractPage(\n  topicId: string\n): Promise<AbstractPage> {\n  const doc = await db.getTopic(topicId).catch(reportError);\n  if (!doc) {\n    return {\n      title: topicId,\n      sections: [\n        {\n          text: 'This page does not have any content yet.',\n        },\n      ],\n    };\n  }\n\n  const sections = await Promise.all([\n    todoSection(doc),\n    frontSection(doc),\n    listSections(doc),\n    otherFieldsSection(doc),\n  ]);\n\n  return {\n    title: deriveTitle(doc),\n    breadcrumbs: await breadcrumbs(doc),\n    sections: sections.flat(),\n  };\n}\n\nasync function todoSection(doc: models.Doc): Promise<Section | never[]> {\n  const divs = await listFieldNameDivs(TodoListFieldNames, doc);\n  if (divs.length === 0) {\n    return [];\n  }\n\n  return {\n    title: 'TODO',\n    divs,\n  };\n}\n\nasync function frontSection(doc: models.Doc) {\n  const { list } = doc;\n  const isShallow = listIsShallow(list);\n\n  if (!doc.text && !isShallow) {\n    return [];\n  }\n\n  return {\n    // TODO src, props\n    text: doc.text,\n    list: await maybeLabelRefs(isShallow ? undefined : doc.list),\n  } as Section;\n}\n\nasync function listSections(doc: models.Doc): Promise<Section[]> {\n  const { list } = doc;\n  if (!list || listIsShallow(list)) {\n    return [];\n  }\n\n  return Promise.all(\n    list.map(async (s: any) => {\n      if (typeof s === 'string' && s.startsWith('/')) {\n        const sectionDoc = await db.getTopic(s);\n        return topicSection(sectionDoc);\n      }\n\n      return {\n        text: s,\n      };\n    })\n  );\n}\n\nasync function topicSection(doc: models.Doc): Promise<Section> {\n  return {\n    title: deriveTitle(doc),\n    text: doc.text,\n    list: await maybeLabelRefs(doc.list),\n    divs: await listFieldNameDivs(NestedSectionListFieldNames, doc),\n  } as Section;\n}\n\nasync function listFieldNameDivs(names: string[][], doc: models.Doc) {\n  const p = await Promise.all(\n    names.map(async ([field, heading]) => {\n      if (!doc[field]) return [];\n      return [\n        {\n          heading,\n          list: await maybeLabelRefs(doc[field] as any[]),\n        },\n      ];\n    })\n  );\n\n  return p.flat();\n}\n\nasync function appendQueueToPage(doc: models.Doc) {\n  const notes = await db.getNotes(doc.id);\n  if (notes.length === 0) {\n    return;\n  }\n\n  notes.forEach(item => {\n    doc.queue = doc.queue || [];\n    doc.queue.unshift(item);\n  });\n}\n\nasync function otherFieldsSection(doc: models.Doc) {\n  await appendQueueToPage(doc);\n\n  const divs = await listFieldNameDivs(LastSectionListFieldNames, doc);\n  if (divs.length === 0) {\n    return [];\n  }\n\n  return {\n    divs,\n  };\n}\n\nasync function maybeLabelRefs(\n  list: undefined | any[]\n): Promise<undefined | any[]> {\n  if (!list || list.length === 0) return;\n\n  return Promise.all(\n    list.map(async v => {\n      // v could be an object from links\n      if (typeof v === 'string' && v.startsWith('/')) {\n        return refToTextObject(v);\n      }\n\n      return v;\n    })\n  );\n}\n\nasync function refToTextObject(topicId: string) {\n  const topic = await db.getTopic(topicId);\n  if (topic.title) {\n    return {\n      ref: topicId,\n      label: deriveTitle(topic),\n    };\n  } else if (!topic.text) {\n    return {\n      ref: topicId,\n      label: deriveTitle(topic),\n    };\n  } else {\n    return {\n      ref: topicId,\n      text: topic.text,\n      src: await maybeResolveSrc(topic.src),\n    };\n  }\n}\n\n// could be lots of things\nasync function maybeResolveSrc(src: undefined | models.Link) {\n  if (!src) return;\n  if (typeof src !== 'string') {\n    return src;\n  } else if (src.startsWith('/')) {\n    const srcNode = await db.getTopic(src);\n    return {\n      ref: src,\n      label: deriveTitle(srcNode),\n    };\n  } else {\n    return src;\n  }\n}\n\nfunction deriveTitle(n: models.Doc): string {\n  if (!n) return 'Missing Page';\n\n  let title = n.title || n.join;\n\n  if (!title && n.link) {\n    if (typeof n.link === 'string') {\n      title = n.link;\n    } else if (models.isLabeledLink(n.link)) {\n      title = n.link.link;\n    } else if (models.isSearchLink(n.link)) {\n      title = n.link.search;\n    }\n  }\n\n  return title || 'Note';\n}\n\nfunction listIsShallow(list: undefined | any[]): boolean {\n  return (\n    list !== undefined &&\n    list.every(s => typeof s === 'string' && !s.startsWith('/'))\n  );\n}\n\nasync function breadcrumbs(doc: models.Doc) {\n  if (!doc.context) return undefined;\n\n  // This dates back to the deeply nested path style keys used\n  // as contexts\n  const fragments: string[] = doc.context.split('/').slice(1);\n  const contextPaths = fragments.map(\n    (fragment, index) => `/${fragments.slice(0, index + 1).join('/')}`\n  );\n\n  return maybeLabelRefs(contextPaths);\n}\n","import PouchDB from 'pouchdb';\nimport { StringQuad, ValidLiteralType } from './rdf';\n\nexport interface Note {\n  id: string;\n  text: string;\n  created_at: number;\n  seq: number | string;\n  topic_id: string;\n}\n\nexport interface ShortDoc {\n  created_at?: number;\n  title?: string;\n  join?: string;\n  text?: string;\n  src?: Link;\n  link?: Link;\n  context?: string;\n  topic_id?: string;\n  queue?: string[];\n  list?: string[];\n  links?: LinkList;\n  props?: DumbProps;\n  patches?: DocChangeEntry[];\n  [key: string]: DocValueTypes;\n}\n\nexport interface Doc extends ShortDoc {\n  id: string;\n  created_at?: number;\n  [key: string]: DocValueTypes;\n}\n\nexport interface DumbProps {\n  quanity?: string;\n  author?: string;\n  [key: string]: string | undefined;\n}\n\nexport interface DocChangeEntry {\n  op: 'add' | 'remove';\n  field: string;\n  value: ValidLiteralType;\n}\n\nexport type LinkList = Link[];\nexport type Link = string | LabeledLink | SearchLink;\nexport interface SearchLink {\n  search: string;\n}\nexport interface LabeledLink {\n  title: string;\n  link: string;\n}\nexport type EditorArrayItemTypes = Link | MaybeLabeledRef;\nexport type DocArrayValueTypes = string[] | LinkList;\nexport type RegularDocValueTypes =\n  | string[]\n  | string\n  | number\n  | undefined\n  | Link\n  | LinkList\n  | DumbProps;\nexport type DocValueTypes = RegularDocValueTypes | DocChangeEntry[];\n\nexport type ExistingDoc = PouchDB.Core.ExistingDocument<Doc>;\nexport type DocUpdate = PouchDB.Core.PutDocument<Doc> & PouchDB.Core.IdMeta;\nexport type RdfDoc = StringQuad;\nexport type CouchDocTypes = Doc | RdfDoc | Note;\nexport type NewNote = PouchDB.Core.PutDocument<Note>;\n\nexport interface EditorDoc {\n  text?: string;\n  queue?: RefList;\n  links?: LinkList;\n  [key: string]: EditorValueTypes;\n}\n\nexport interface LabeledRef {\n  label: string;\n  ref: string;\n}\n\nexport type EditorValueTypes = RegularDocValueTypes | RefList;\nexport type RefList = MaybeLabeledRef[];\nexport type MaybeLabeledRef = string | LabeledRef;\nexport type EditorStructure = Record<string, EditorDoc>;\n\nexport const StorageFields = ['_rev', '_id', '_deleted', 'id', 'patches'];\nexport function removeStorageAttributes(\n  doc: ExistingDoc | DocUpdate\n): ShortDoc {\n  const clone = { ...doc } as any;\n\n  StorageFields.forEach(k => {\n    delete clone[k];\n  });\n\n  return clone as ShortDoc;\n}\n\nexport function isStorageField(k: string) {\n  return StorageFields.indexOf(k) > -1;\n}\n\nexport function isPatches(k: string, v: DocValueTypes): v is DocChangeEntry[] {\n  return Array.isArray(v) && k === 'patches';\n}\n\nexport function isDocArrayField(\n  k: string,\n  v: DocValueTypes\n): v is DocArrayValueTypes {\n  return Array.isArray(v) && k !== 'patches';\n}\n\nexport function isLabeledRef(l: any): l is LabeledRef {\n  if (typeof l === 'string') {\n    return false;\n  }\n\n  return !!(l as LabeledRef).ref;\n}\n\nexport function isSearchLink(l: any): l is SearchLink {\n  if (typeof l === 'string') {\n    return false;\n  }\n\n  return !!(l as SearchLink).search;\n}\n\nexport function isLabeledLink(l: any): l is LabeledLink {\n  if (typeof l === 'string') {\n    return false;\n  }\n\n  return !!(l as LabeledLink).link;\n}\n\nexport function isProps(k: string, o: DocValueTypes): o is DumbProps {\n  return k === 'props';\n}\n","import React, { Component } from 'react';\nimport { RouteComponentProps } from 'react-router';\nimport { Link } from 'react-router-dom';\nimport { Menu } from './menu';\nimport './topic_page.css';\nimport {\n  buildAbstractPage,\n  AbstractPage,\n  Section,\n} from '../utils/abstract_page';\nimport { reportError } from '../utils/errors';\n\ntype TopicPageProps = RouteComponentProps<{\n  topicId: string;\n}>;\n\ninterface TopicPageState {\n  page?: AbstractPage;\n  loadedFor?: string;\n}\n\nexport class TopicPage extends Component<TopicPageProps, TopicPageState> {\n  constructor(props: TopicPageProps) {\n    super(props);\n    this.state = {};\n  }\n\n  componentWillUnmount() {}\n\n  fetchContent(topicId: string) {\n    reportError(async () => {\n      // TODO find a way to cancel this from componentWillUnmount\n      const page = await buildAbstractPage(`/${topicId}`);\n      this.setState({\n        loadedFor: topicId,\n        page,\n      });\n    });\n  }\n\n  render() {\n    const { topicId } = this.props.match.params;\n\n    if (this.state.loadedFor !== topicId) {\n      this.fetchContent(topicId);\n    }\n\n    return (\n      <div className=\"topicPage\">\n        <Menu>\n          <li>\n            <Link to=\"/index\">index</Link>\n          </li>\n          <li>\n            <Link to={'/add_note/' + topicId}>add note</Link>\n          </li>\n        </Menu>\n\n        <div className=\"header\">\n          {this.state.page && (\n            <Breadcrumbs breadcrumbs={this.state.page.breadcrumbs} />\n          )}\n          <h1 className=\"title\">\n            {this.state.page ? this.state.page.title : topicId}\n          </h1>\n        </div>\n\n        {this.state.page ? (\n          renderSections(this.state.page.sections)\n        ) : (\n          <section>\n            <p>Loading...</p>\n          </section>\n        )}\n      </div>\n    );\n  }\n}\n\nfunction renderSections(sections: Section[]) {\n  return sections.map((s, i) => {\n    return (\n      <section key={i}>\n        {s.title && <h2 className=\"title\">{s.title}</h2>}\n        {s.text && <p>{s.text}</p>}\n        {s.list && simpleList(s.list)}\n        {s.divs && sectionDivs(s.divs)}\n      </section>\n    );\n  });\n}\n\nfunction sectionDivs(divs: any[]) {\n  return divs.map((d, i) => {\n    return (\n      <div key={i}>\n        {d.heading && <h3 className=\"title\">{d.heading}</h3>}\n        {simpleList(d.list)}\n      </div>\n    );\n  });\n}\n\nfunction simpleList(list: any[]) {\n  return (\n    <ul>\n      {list.map((s, i) => (\n        <li key={i}>{textItem(s)}</li>\n      ))}\n    </ul>\n  );\n}\n\nfunction Breadcrumbs(props: { breadcrumbs: undefined | any[] }) {\n  return <></>;\n}\n\nfunction textItem(item: any) {\n  if (typeof item === 'string') {\n    if (item.startsWith('http')) {\n      return buildAnchorElement(item);\n    }\n    return <p>{item}</p>;\n  } else if (item.link || item.search) {\n    return buildAnchorElement(item);\n  } else if (item.label) {\n    return refLink(item.ref, item.label);\n  } else {\n    return (\n      <p>\n        {item.text}\n        {renderSrc(item.src)}({refLink(item.ref, 'more', 'moreLink')})\n      </p>\n    );\n  }\n}\n\nfunction renderSrc(src: any) {\n  if (!src) {\n    return undefined;\n  } else if (typeof src === 'string') {\n    return <span>- ${src}</span>;\n  } else if (src.ref) {\n    return refLink(src.ref, src.label);\n  } else {\n    // TODO replace this, it could be a labeled link\n    return <pre>{JSON.stringify(src)}</pre>;\n  }\n}\n\nfunction buildAnchorElement(obj: any) {\n  const mobile = document.documentElement.clientWidth < 800;\n\n  if (typeof obj === 'string' || obj.link) {\n    let target = obj;\n    let text = obj;\n\n    if (typeof obj !== 'string') {\n      target = obj.link;\n      text = obj.title || obj.link;\n    }\n\n    if (text.startsWith('https://en.wikipedia.org/wiki')) {\n      text = `Wikipedia: ${text\n        .replace('https://en.wikipedia.org/wiki/', '')\n        .replace(/_/g, ' ')}`;\n    } else if (text.indexOf('pinboard.in/u:curzonj/') !== -1) {\n      text = `Pinboard: ${text\n        .replace(/https?:\\/\\/pinboard.in\\/u:curzonj\\//, '')\n        .split('/')\n        .filter((l: string) => l !== '')\n        .flatMap((l: string) => l.replace(/^t:/, ''))\n        .join(', ')}`;\n      target = target.replace(/^http:\\/\\//, 'https://');\n      if (mobile) {\n        target = target.replace('pinboard.in', 'm.pinboard.in');\n      }\n    }\n\n    return (\n      <a target=\"_blank\" rel=\"noopener noreferrer\" href={target}>\n        {text}\n      </a>\n    );\n  }\n  if (obj.search) {\n    return (\n      <a\n        target=\"_blank\"\n        rel=\"noopener noreferrer\"\n        href={'https://google.com/search?q=' + encodeURIComponent(obj.search)}\n      >\n        Google: {obj.search}\n      </a>\n    );\n  }\n\n  return undefined;\n}\n\nfunction refLink(link: string, text: string, cssClass: string = 'refLink') {\n  return (\n    <Link className={cssClass} to={encodeURI(link)}>\n      {text || link}\n    </Link>\n  );\n}\n","import React, { Component } from 'react';\nimport { RouteComponentProps } from 'react-router';\nimport { Menu } from './menu';\n\ninterface NotePageParams {\n  topicId: string;\n}\n\nexport class NotePage extends Component<RouteComponentProps<NotePageParams>> {\n  componentDidMount() {}\n\n  componentWillUnmount() {}\n\n  hello() {\n    console.log('Hello world');\n  }\n\n  render() {\n    const { topicId } = this.props.match.params;\n\n    return (\n      <>\n        <Menu>\n          <li>\n            <button type=\"button\" className=\"link-button\" onClick={this.hello}>\n              done\n            </button>\n          </li>\n        </Menu>\n        <h2>{topicId}</h2>\n      </>\n    );\n  }\n}\n","import React, { Component } from 'react';\nimport { RouteComponentProps } from 'react-router';\nimport { Menu } from './menu';\nimport { reportError } from '../utils/errors';\nimport * as db from '../utils/db';\nimport './login_page.css';\n\nexport class LoginPage extends Component<\n  RouteComponentProps,\n  { value: string }\n> {\n  constructor(props: RouteComponentProps) {\n    super(props);\n    this.state = { value: '' };\n  }\n\n  onKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {\n    if (e.which === 13 && (e.metaKey || e.shiftKey)) this.onSubmit(e);\n  };\n\n  onSubmit = (e: React.SyntheticEvent) => {\n    e.preventDefault();\n\n    reportError(async () => {\n      await db.configure(this.state.value);\n      this.props.history.push('/index');\n    });\n  };\n\n  onChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {\n    if (e && e.target) {\n      this.setState({ value: e.target.value });\n    }\n  };\n\n  render() {\n    return (\n      <div className=\"loginPage\">\n        <Menu>\n          <li>\n            <button\n              type=\"button\"\n              className=\"link-button\"\n              onClick={this.onSubmit}\n            >\n              done\n            </button>\n          </li>\n        </Menu>\n\n        <div className=\"header\">\n          <h1 className=\"title\">Enter the configuration</h1>\n        </div>\n\n        <form>\n          <textarea\n            onKeyDown={this.onKeyDown}\n            autoComplete=\"on\"\n            autoCapitalize=\"sentences\"\n            required\n            onChange={this.onChange}\n            value={this.state.value}\n          ></textarea>\n        </form>\n      </div>\n    );\n  }\n}\n","import React, { Component } from 'react';\nimport {\n  BrowserRouter as Router,\n  Route,\n  Switch,\n  Redirect,\n} from 'react-router-dom';\nimport { withRouter, RouteComponentProps } from 'react-router';\nimport './app.css';\nimport { TopicPage } from './topic_page';\nimport { NotePage } from './note_page';\nimport { LoginPage } from './login_page';\nimport { initialize as dbInitialize } from '../utils/db';\nimport { reportError } from '../utils/errors';\n\nclass ScrollToTopInner extends Component<RouteComponentProps> {\n  componentDidUpdate(prevProps: RouteComponentProps) {\n    if (this.props.location.pathname !== prevProps.location.pathname) {\n      window.scrollTo(0, 0);\n    }\n  }\n\n  render() {\n    return this.props.children;\n  }\n}\nconst ScrollToTop = withRouter(ScrollToTopInner);\n\nconst HistoryExporter = withRouter((props: RouteComponentProps) => {\n  reportError(async () => {\n    const ok = await dbInitialize();\n    if (!ok) {\n      props.history.push('/login');\n    }\n  });\n\n  return <></>;\n});\n\nfunction determineBasename() {\n  if (process.env.PUBLIC_URL === undefined || process.env.PUBLIC_URL === '') {\n    return undefined;\n  }\n\n  console.log(process.env.PUBLIC_URL);\n\n  const url = new URL(process.env.PUBLIC_URL);\n  return url.pathname;\n}\n\nexport const App: React.FC = () => {\n  return (\n    <Router basename={determineBasename()}>\n      <HistoryExporter />\n\n      <ScrollToTop>\n        <Switch>\n          <Redirect from=\"/\" to=\"/index\" exact />\n          <Route path=\"/login\" component={LoginPage} />\n          <Route path=\"/add_note/:topicId\" component={NotePage} />\n          <Route path=\"/:topicId\" component={TopicPage} />\n        </Switch>\n      </ScrollToTop>\n    </Router>\n  );\n};\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './web/index.css';\nimport { App } from './web/comps/app';\nimport * as serviceWorker from './web/serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}